import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,o as a,a as r}from"./app-DBc2jY3V.js";const i={};function o(l,e){return a(),d("div",null,e[0]||(e[0]=[r(`<h1 id="_03-基类qobject" tabindex="-1"><a class="header-anchor" href="#_03-基类qobject" aria-hidden="true">#</a> 03.基类QObject</h1><p><code>QObject</code>是所有的Qt对象的基类,所有的对象都是直接或者间接的继承自QObject</p><h2 id="对象名称-属性" tabindex="-1"><a class="header-anchor" href="#对象名称-属性" aria-hidden="true">#</a> 对象名称,属性</h2><h3 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setObjectName(&quot;唯一名称&quot;)</td><td>给一个Qt对象设置一个名称\`\`一般这个名称是唯一的,当做对象的ID来使用</td></tr><tr><td>objectName()</td><td>获取一个Qt对象的名称</td></tr><tr><td>setProperty(&quot;属性名称&quot;,值)</td><td>给一个Qt对象动态的添加一个属性与值</td></tr><tr><td>property(&quot;属性名称&quot;)</td><td>获取一个对象的属性值</td></tr><tr><td>dynamicPropertyNames()</td><td>获取一个对象中所有通过setProperty()设置的属性名称</td></tr></tbody></table><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h3><ul><li><p>用于qss的ID选择器,属性选择器,方便统一设置样式</p><p><code>QObject.qss</code></p><div class="language-QSS line-numbers-mode" data-ext="QSS"><pre class="language-QSS"><code>QLabel#notice {
    font-size: 20px;
    color: gray;
    border: 1px solid gray;
    border-radius: 8px;
}
QLabel#notice[notice_level=&quot;normal&quot;]{
    color: green;
    border-color: green;
}
QLabel#notice[notice_level=&quot;warning&quot;]{
    color: yellow;
    border-color: yellow;
}
QLabel#notice[notice_level=&quot;error&quot;]{
    color: red;
    border-color: red;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>用于装饰器的信号与槽</p></li></ul><h2 id="父子对象操作" tabindex="-1"><a class="header-anchor" href="#父子对象操作" aria-hidden="true">#</a> 父子对象操作</h2><h3 id="api-1" tabindex="-1"><a class="header-anchor" href="#api-1" aria-hidden="true">#</a> API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setParent(parent)</td><td>设置父对象,父对象只能设置一个</td></tr><tr><td>parent()</td><td>获取父对象</td></tr><tr><td>children()</td><td>获取所有直接子对象,不包括间接的子对象如孙子辈的</td></tr><tr><td>findChild(参数1, 参数2, 参数3)</td><td>获取某一个指定名称和类型的子对象</td></tr></tbody></table><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>参数1:QObject对象或者多个QObject对象元组
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>参数2:setProperty设置的属性名称,可以省略
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>参数3:查找选项,有两个可选
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Qt.FindChildrenRecursively</code>(递归查找,默认选项)/<code>Qt.FindDirectChildrenOnly</code>(只查找直接子对象) |</p><h3 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h3><h4 id="内存管理机制" tabindex="-1"><a class="header-anchor" href="#内存管理机制" aria-hidden="true">#</a> 内存管理机制</h4><p>当创建一个QObject时,如果使用了其他对象作为其父对象 那么,它就会被添加到父对象的children()列表中.当父对象被销毁时,这个QObject也会被销毁</p><ul><li>涉及到Qt对象内存管理机制</li><li>如果一个控件,没有任何父控件,那么就会被当成顶层控件(窗口)</li><li>如果想要一个控件被包含在另外一个控件内部,就需要设置父子关系</li></ul><h4 id="顶层控件" tabindex="-1"><a class="header-anchor" href="#顶层控件" aria-hidden="true">#</a> 顶层控件</h4><p>如果一个控件,没有任何父控件,那么就会被当成顶层控件(窗口)</p><p>多个顶层窗口相互独立</p><p>如果想要一个控件被包含在另外一个控件内部,就需要设置父子关系</p><ul><li>显示位置受父控件约束</li><li>生命周期也被父对象接管</li></ul><h3 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h3><blockquote><p>1.创建两个独立的窗口</p><blockquote><p>要求</p></blockquote><blockquote><p>设置不同的标题 社会我顺哥 人狠话不多 涉及知识点 创建窗口 设置窗口标题 掌握级别 了解如果创建控件没有设置任何父对象, 会有什么效果</p></blockquote></blockquote><blockquote><p>2.创建一个窗口, 包含另外两个子控件QWidget</p><blockquote><p>要求</p></blockquote><blockquote><p>两个子控件必须在同一个窗口内部 涉及知识点 控件的父子关系 掌握级别 掌握给一个控件设置父控件的两种方式</p></blockquote></blockquote><blockquote><p>3.创建一个窗口, 包含多个子控件QWidget和QLabel</p><blockquote><p>要求</p></blockquote><blockquote><p>要求让所有的QLabel类型子控件都设置背景颜色为cyan 即使后续再增加新的QLabel子控件 涉及知识点 控件的父子关系设置 获取一个控件的子控件 样式设置 掌握级别 了解</p></blockquote></blockquote><h2 id="信号处理" tabindex="-1"><a class="header-anchor" href="#信号处理" aria-hidden="true">#</a> 信号处理</h2><h3 id="api-2" tabindex="-1"><a class="header-anchor" href="#api-2" aria-hidden="true">#</a> API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>widget.信号方法.connect(槽函数)</td><td>连接信号与槽</td></tr><tr><td>obj.disconnect()</td><td>取消连接信号与槽<br>obj:可为空间或信号 <code> 控件:取消控件的所有信号连接</code> 信号:取消指定信号的连接</td></tr><tr><td>widget.blockSignals(bool)</td><td>临时(取消)阻止指定控件所有的信号与槽的连接</td></tr><tr><td>widget.signalsBlocked()</td><td>信号是否被阻止</td></tr><tr><td>widget.receivers(信号)</td><td>返回连接到信号的接收器数量</td></tr></tbody></table><h3 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2" aria-hidden="true">#</a> 应用场景</h3><ul><li>监听信号, 响应用户行为</li><li>信号与槽机制</li></ul><h3 id="案例-1" tabindex="-1"><a class="header-anchor" href="#案例-1" aria-hidden="true">#</a> 案例</h3><blockquote><p>1.当用户点击按钮的时候, 打印&quot;点我嘎哈?&quot;</p><blockquote><p>要求</p></blockquote><blockquote><p>用户点了按钮, 你就负责打印 涉及知识点 按钮创建, 设置 监听按钮点击的信号 掌握级别 了解信号监听部分</p></blockquote></blockquote><blockquote><p>2.在所有修改的窗口标题前, 添加前缀&quot;撩课-&quot;</p><blockquote><p>要求</p></blockquote><blockquote><p>比如, 后续我们修改标题为&quot;Hello Sz&quot;; 最终会自动变为&quot;撩课-Hello Sz!&quot; 支持多次修改 涉及知识点 设置窗口标题 监听窗口标题改变信号 临时取消/恢复信号与槽的连接 掌握级别 了解信号监听部分</p></blockquote></blockquote><h2 id="类型判定" tabindex="-1"><a class="header-anchor" href="#类型判定" aria-hidden="true">#</a> 类型判定</h2><h3 id="api-3" tabindex="-1"><a class="header-anchor" href="#api-3" aria-hidden="true">#</a> API</h3><ul><li>isWidgetType() 是否是控件类型 继承自QWidget类</li><li>inherits(父类) 一个对象是否继承(直接或者间接)自某个类</li></ul><h3 id="应用场景-3" tabindex="-1"><a class="header-anchor" href="#应用场景-3" aria-hidden="true">#</a> 应用场景</h3><p>过滤筛选控件</p><h3 id="案例-2" tabindex="-1"><a class="header-anchor" href="#案例-2" aria-hidden="true">#</a> 案例</h3><blockquote><p>1.创建一个窗口, 包含多个QLabel或其他控件</p><blockquote><p>要求</p></blockquote><blockquote><p>将包含在窗口内所有的QLabel控件, 设置背景色cyan 涉及知识点 子控件获取 控件类型判定 样式设置 掌握级别 掌握控件判定部分</p></blockquote></blockquote><h2 id="对象删除" tabindex="-1"><a class="header-anchor" href="#对象删除" aria-hidden="true">#</a> 对象删除</h2><p><code>obj.deleteLater()</code></p><p>删除一个对象时, 也会解除它与父对象之间的关系 deleteLater()并没有将对象立即销毁,而是向主消息循环发送了一个event,下一次主消息循环收到这个event之后才会销毁对象 这样做的好处是可以在这些延迟删除的时间内完成一些操作,坏处就是内存释放会不及时</p><p>想要移除某一个对象的时候使用,bu同于python的del方法,会删除对象对应的子组件</p><h2 id="事件处理" tabindex="-1"><a class="header-anchor" href="#事件处理" aria-hidden="true">#</a> 事件处理</h2><h3 id="api-4" tabindex="-1"><a class="header-anchor" href="#api-4" aria-hidden="true">#</a> API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>childEvent()</code></td><td></td></tr><tr><td><code>customEvent()</code></td><td></td></tr><tr><td><code>eventFilter()</code></td><td></td></tr><tr><td><code>installEventFilter()</code></td><td></td></tr><tr><td><code>removeEventFilter</code></td><td></td></tr><tr><td><code>event()</code></td><td></td></tr></tbody></table><h3 id="应用场景-4" tabindex="-1"><a class="header-anchor" href="#应用场景-4" aria-hidden="true">#</a> 应用场景</h3><ul><li>事件机制</li><li>拦截事件, 监听特定行为</li></ul><h2 id="定时器" tabindex="-1"><a class="header-anchor" href="#定时器" aria-hidden="true">#</a> 定时器</h2><h3 id="api-5" tabindex="-1"><a class="header-anchor" href="#api-5" aria-hidden="true">#</a> API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>startTimer(ms, Qt.TimerType) -&gt; timer_id</code></td><td>开启一个定时器 <code> Qt.TimerType</code> Qt.PreciseTimer 精确定时器:尽可能保持毫秒准确 <code> Qt.CoarseTimer 粗定时器:5%的误差间隔</code> Qt.VeryCoarseTimer 很粗的定时器:只能到秒级\`\` timer_id 定时器的唯一标识</td></tr><tr><td><code>killTimer(timer_id)</code></td><td>根据定时器ID,杀死定时器</td></tr><tr><td><code>timerEvent()</code></td><td>定时器执行事件</td></tr></tbody></table><h3 id="应用场景-5" tabindex="-1"><a class="header-anchor" href="#应用场景-5" aria-hidden="true">#</a> 应用场景</h3><ul><li>轮询</li><li>倒计时</li></ul><h3 id="案例-3" tabindex="-1"><a class="header-anchor" href="#案例-3" aria-hidden="true">#</a> 案例</h3><blockquote><p>1.创建一个窗口, 并设置一个子控件QLabel</p><blockquote><p>要求</p></blockquote><blockquote><p>展示10s倒计时 倒计时结束, 就停止计时 涉及知识点 标签额创建和设置 自定义标签类的封装 定时器的使用 掌握级别 了解定时器基本操作</p></blockquote></blockquote><blockquote><p>2.创建一个窗口, 通过定时器不断增加该窗口的尺寸大小</p><blockquote><p>要求</p></blockquote><blockquote><p>每100ms 宽高均增加1px 涉及知识点 窗口控件的封装 定时器的使用 掌握级别 了解定时器</p></blockquote></blockquote><h2 id="语言翻译" tabindex="-1"><a class="header-anchor" href="#语言翻译" aria-hidden="true">#</a> 语言翻译</h2><p><code>tr()</code></p><p>应用场景:多语言国际化支持</p><h2 id="信号" tabindex="-1"><a class="header-anchor" href="#信号" aria-hidden="true">#</a> 信号</h2><table><thead><tr><th>新号</th><th>说明</th></tr></thead><tbody><tr><td>objectNameChanged(objectName)</td><td>对象名称发生改变时发射此信号</td></tr><tr><td>destroyed(obj)</td><td>对象被销毁时, 发射此信号</td></tr></tbody></table>`,66)]))}const h=t(i,[["render",o],["__file","03基类QObject.html.vue"]]);export{h as default};
