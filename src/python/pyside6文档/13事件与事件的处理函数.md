---
order: 13
---

# 13.事件与事件的处理函数

事件(event)和前文所介绍的经常用的信号一样,也是实现可视化控件之间联动的重要方法。

事件是程序收到外界的输入,处于某种状态时自动发送的信号。

事件有固定的类型每种类型有自己的处理函数,用户只要重写这些函数,即可达到特定的目的。

通过事件可以用一个控件监测另外一个控件,并可过滤被监测控件发出的事件。

## 事件的类型与处理函数

### 事件的概念

可视化应用程序在接受外界输入设备的输入时,例如鼠标、键盘等的操作,会对输入设备输入的信息进行分类,根据分类的不同,用不同的函数进行处理,做出不同的反应。

外界对 PySide程序进行输人信息的过程称为事件,例如在窗口上单击鼠标、用鼠标拖动窗口在输人框中输人数据等,这些都是外界对程序的输人,都可以称为事件。

PySide 程序对外界的输人进行处理的过程称为事件处理,根据外界输入信息的不同,处理事件的函数也不同。

前面编制的可视化程序中,在主程序中都会创建一个 QApplication 的应用程序实例对象,然后调用实例对象的 exec()函数,这将使应用程序进入一个循环,不断监听外界输入的信息。当输人的信息满足某种分类时,将会产生一个事件对象 QEvent(),事件对象中记录了外界输人的信息,并将事件对象发送给处理该事件对象的函数进行处理。

事件与前面讲过的信号与槽相似,但是又有不同。信号是指控件或窗口本身满足一定条件时,发送一个带数据的信息或不带数据的信息,需要编程人员为这个信息单独写处理这个信息的槽函数,并将信号和槽函数关联,发送信号时,自动执行与之关联的槽函数。而事件是外界对程序的输人,将外界的输人进行分类后交给函数处理,处理事件的函数是固定的,只需要编程人员把处理事件的函数重写,来达到处理外界输入的目的,而不需要将事件与处理事件的函数进行连接,系统会自动调用能处理事件的函数,并把相关数据作为实参传递给处理事件的函数。

下面是一个处理鼠标单击事件的程序,在窗口的空白处单击鼠标左键,在 QLineEdit 控件上显示出鼠标单击点处的窗口坐标值,单击鼠标右键,显示右键单击处屏幕坐标值。

单击鼠标左键或右键将会产生QMouseEvent 事件,QMouseEvent事件的实例对象中有与鼠标事件相关的属性,如 button()方法获取单击的是左键还是右键,x()和 y()方法取鼠标单击点处窗口坐值,globalX()和 globalY()方法获取鼠标单击点处屏幕坐标值。

QWidget窗口处理 QMouseEvent 事件的函数有:

- mouseDoubleClickEvent(QMouseEvent)
- mouseMoveEvent(QMouseEvent)
- mousePressEvent(QMouseEvent)
- mouseReleaseEvent(QMouseEvent)
- moveEvent(QMoveEvent)

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:31
# File_name: 01-简单的鼠标点击事件.py
import PySide6.QtGui
from PySide6.QtWidgets import QApplication, QWidget, QLabel
from PySide6.QtCore import Qt
import sys


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.resize(500, 500)
        self.qlabel = QLabel(self)
        self.qlabel.setGeometry(15, 5, 500, 30)
        self.qlabel.setText("请点击")

    def mousePressEvent(self, event: PySide6.QtGui.QMouseEvent) -> None:  # 重写处理mousePress 事件的函数
        super().mousePressEvent(event)

        template1 = "单击点的窗口坐标是x:{} y:{}"
        template2 = "单击点的屏幕坐标是x:{} y:{}"

        if event.button() == Qt.LeftButton:  # button()获取键或右键
            string = template1.format(event.position().x(), event.position().y())  # x()和()获取窗口坐标
            self.qlabel.setText(string)

        if event.button() == Qt.RightButton:  # globalX()和globalY()获取全局坐标
            string = template2.format(event.globalPosition().x(), event.globalPosition().y())
            self.qlabel.setText(string)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```



### QEvent类

QEvent类是所有事件的基类,它在 QtCore 模块中。

外界输人给序的信息首先交给QEvent 进行分类,得到不同类型的事件,然后系统将事件及相关信息交给控件或窗口的事件处理函数进行处理,得到对外界输人的响应QEvent 类的属性只有 accepted。

常用方法如表所示,主要方法介绍如下:

| QEvent的方法及参数类型                  | 返回值的类型 | 说明                               |
| --------------------------------------- | ------------ | ---------------------------------- |
| accept()                                | None         | 事件被接受                         |
| ignore()                                | None         | 事件被拒绝                         |
| isAccepted()                            | bool         | 事件是否被接受                     |
| setAccepted(accepted: bool)             | None         | 设置事件是否被接受                 |
| clone()                                 | QEvent       | 重写该函数,返回事件的复本          |
| isPointerEvent()                        | bool         | 是QPointerEvent 事件时返回True     |
| isSinglePointEvent()                    | bool         | 是 QSinglePointEvent事件时返回True |
| spontaneous()                           | bool         | 获取事件是否立即被处理             |
| type()                                  | QEvent.Type  | 获取事件的类型                     |
| [static]registerEventType(hint: int=—1) | int          | 注册新的事件类型                   |

> - 用accept()或 setAccepted(True)方法接受一个事件
> - 用ignore()或 setAccepted(False)方法拒绝一个事件。
> - 被接受的事件不会再传递给其他对象;被拒绝的事件会传递给其他对象处理,如果没有对象处理,则该事件会被丢弃。

> - 如果事件被QWidget的event()函数进行了处理则用spontaneous()方法的返回值是True,否则返回值是False。
> - event()函数根据事件类型起到分发事件到指定处理函数的作用,可以在event()函数中对事件进行处理
>   - 用registerEventType(hint:int=-1)方法可以注册一个新事件类型其中hint的取值介于QEventUser(1000)和 QEvent.MaxUser(65535)之间,返回新事件的D号。



用type()方法可以返回事件的类型。QEvent中定义了事件的类型,QEent定义的主要事件类型如表所示:

| 事件类型常量(QEvent.Type)            | 值   | 所属事件类                      | 说明                                      |
| ------------------------------------ | ---- | ------------------------------- | ----------------------------------------- |
| QEvent.None                          | 0    | -                               | 不是一个事件                              |
| QEvent.ActivationChange              | 99   | -                               | 顶层窗口激活状态发生变化                  |
| QEvent.ApplicationFontChange         | 36   | -                               | 程序的默认字体发生变化                    |
| QEvent.ApplicationPaletteChange      | 38   | -                               | 程序的默认调色板发生变化                  |
| QEvent.ApplicationStateChange        | 214  | -                               | 应用程序的状态发生变化                    |
| QEvent.ApplicationWindowIconChange   | 35   | -                               | 应用程序的图标发生变化                    |
| QEvent.Clipboard                     | 40   | -                               | 剪贴板的内容发生改变                      |
| QEvent.ContentsRectChange            | 178  | -                               | 控件内容区外边距发生改变                  |
| QEvent.CursorChange                  | 183  | -                               | 控件的鼠标指针发生改变                    |
| QEvent.DynamicPropertyChange         | 170  | -                               | 动态属性已添加、更改或删除                |
| QEvent.EnabledChange                 | 98   | -                               | 控件的enabled状态已更改                   |
| QEvent.EnterEditFocus                | 150  | -                               | 编辑控件获得焦点进行编辑                  |
| QEvent.FontChange                    | 97   | -                               | 控件的字体发生改变                        |
| QEvent.GrabKeyboard                  | 188  | -                               | item获得键盘抓取(仅限QGraphicsItem)       |
| QEvent.GrabMouse                     | 186  | -                               | item获得鼠标抓取(仅限QGraphicsItem)       |
| QEvent.KeyboardLayoutChange          | 169  | -                               | 键盘布局已更改                            |
| QEvent.LanguageChange                | 89   | -                               | 应用程序翻译发生改变                      |
| QEvent.LayoutDirectionChange         | 90   | -                               | 布局的方向发生改变                        |
| QEvent.LayoutRequest                 | 76   | -                               | 控件的布局需要重做                        |
| QEvent.Leave                         | 11   | -                               | 光标离开控件的边界                        |
| QEvent.LeaveWhatsThisMode            | 125  | -                               | 程序离开"What'sThis?"模式                 |
| QEvent.LLeaveEditFocus               | 151  | -                               | 编辑控件失去编辑的焦点                    |
| QEvent.LocaleChange                  | 88   | -                               | 系统区域设置发生改变                      |
| QEvent.ModifiedChange                | 102  | -                               | 控件修改状态发生改变                      |
| QEvent.MouseTrackingChange           | 109  | -                               | 鼠标跟踪状态发生改变                      |
| QEvent.NonClientAreaMouseMove        | 173  | -                               | 光标移动发生在客户区域外                  |
| QEvent.PaletteChange                 | 39   | -                               | 控件的调色板发生改变                      |
| QEvent.ParentAboutToChange           | 131  | -                               | 控件的parent将要更改                      |
| QEvent.ParentChange                  | 21   | -                               | 控件的parent发生改变                      |
| QEvent.PlatformPanel                 | 212  | -                               | 请求-个特定于平台的面板                   |
| QEvent.Polish                        | 75   | -                               | 控件被抛光                                |
| QEvent.PolishRequest                 | 74   | -                               | 控件应该被抛光                            |
| QEvent.ReadOnlyChange                | 106  | -                               | 控件的read-only状态发生改变               |
| QEvent.ShowToParent                  | 26   | -                               | 子控件被显示                              |
| QEvent.StyleChange                   | 100  | -                               | 控件的样式发生改变                        |
| QEvent.ToolTipChange                 | 184  | -                               | 控件的tooltip发生改变                     |
| QEvent.UngrabMouse                   | 187  | -                               | Item失去鼠标抓取(QGraphicsItemQQuickItem) |
| QEvent.UpdateRequest                 | 77   | -                               | 控件应该被重绘                            |
| QEvent.WhatsThisClicked              | 118  | -                               | "What'sThis"帮助链接被单击                |
| QEvent.WindowActivate                | 24   | -                               | 窗口已激活                                |
| QEvent.WindowBlocked                 | 103  | -                               | 窗口被模式对话框阻塞                      |
| QEvent.WindowDeactivate              | 25   | -                               | 窗户被停用                                |
| QEvent.WindowIconChange              | 34   | -                               | 窗口的图标发生改变                        |
| QEvent.WindowTitleChange             | 33   | -                               | 窗口的标题发生改变.                       |
| QEvent.ActionAdded                   | 114  | QActionEvent                    | 一个新QAction被添加                       |
| QEvent.ActionChanged                 | 113  | QActionEvent                    | 一个QAction被改变                         |
| QEvent.ActionRemoved                 | 115  | QActionEvent                    | 一个QAction被移除                         |
| QEvent.ChildAdded                    | 68   | QChildEvent                     | 一个对象获得孩子                          |
| QEvent.ChildPolished                 | 69   | QChildEvent                     | 一个控件的孩子被抛光                      |
| QEvent.ChildRemoved                  | 71   | QChildEvent                     | 一个对象失去孩子                          |
| QEvent.Close                         | 19   | QCloseEvent                     | Widget被关闭                              |
| QEvent.ContextMenu                   | 82   | QContextMenuEvent               | 上下文弹出菜单                            |
| QEvent.DeferredDelete                | 52   | QDeferredDeleteEvent            | 对象被清除后将被删除                      |
| QEvent.DragEnter                     | 60   | QDragEnterEvent                 | 拖放操作时光标进入控件                    |
| QEvent.DragLeave                     | 62   | QDragLeaveEvent                 | 拖放操作时光标离开控件                    |
| QEvent.DragMove                      | 61   | QDragMoveEvent                  | 拖放操作正在进行                          |
| QEvent.Drop                          | 63   | QDropEvent                      | 拖放操作完成                              |
| QEvent.Enter                         | 10   | QEnterEvent                     | 光标进人控件的边界                        |
| QEvent.FileOpen                      | 116  | QFileOpenEvent                  | 文件打开请求                              |
| QEvent.FocusIn                       | 8    | QFocusEvent                     | 控件或窗口获得键盘焦点                    |
| QEvent.FocusOut                      | 9    | QFocusEvent                     | 控件或窗口失去键盘焦点                    |
| QEvent.FocusAboutToChange            | 23   | QFocusEvent                     | 控件或窗口焦点即将改变                    |
| QEvent.Gesture                       | 198  | QGestureEvent                   | 触发了-个手势                             |
| QEvent.GestureOverride               | 202  | QGestureEvent                   | 触发了手势覆盖                            |
| QEvent.UngrabKeyboard                | 189  | QGraphicsItem                   | Item失去键盘抓取                          |
| QEvent.GraphicsSceneContextMenu      | 159  | QGraphicsSceneConte-xtMenuEvent | 在图形场景上弹出右键菜单                  |
| QEvent.GraphicsSceneDragLeave        | 166  | QGraphicsSceneDrag-DropEvent    | 拖放操作时光标离开场景                    |
| QEvent.GraphicsSceneDragMove         | 165  | QGraphicsSceneDrag-DropEvent    | 在场景上正在进行拖放操作                  |
| QEvent.GraphicsSceneDrop             | 167  | QGraphicsSceneDrag-DropEvent    | 在场景上完成拖放操作                      |
| QEvent.GraphicsSceneDragEnter        | 164  | QGraphicsScene-DragDropEvent    | 拖放操作时光标进入场景                    |
| QEvent.GraphicsSceneHoverEnter       | 160  | QGraphicsSceneHoverEvent        | 光标进入图形场景中的悬停项                |
| QEvent.GraphicsSceneHoverLeave       | 162  | QGraphicsSceneHover-Event       | 光标离开图形场景-个悬停项                 |
| QEvent.GraphicsSceneHoverMove        | 161  | QGraphicsSceneHover-Event       | 光标在场景的悬停项内移动                  |
| QEvent.GraphicsSceneMouseDoubleClick | 158  | QGraphicsSceneMouseEvent        | 光标在图形场景中双击                      |
| QEvent.GraphicsSceneMouseMove        | 155  | QGraphicsSceneMouseEvent        | 光标在图形场景中移动                      |
| QEvent.GraphicsSceneMousePress       | 156  | QGraphicsSceneMouse-Event       | 光标在图形场景中按下                      |
| QEventGraphicsSceneMouseRelease      | 157  | QGraphicsSceneMouse-Event       | 光标在图形场景中释放                      |
| QEvent.GraphicsSceneMove             | 182  | QGraphicsSceneMove-Event        | 控件被移动                                |
| QEvent.GraphicsSceneResize           | 181  | QGraphicsSceneResize-Event      | 控件已调整大小                            |
| QEvent.GraphicsSceneWheel            | 168  | QGraphicsSceneWheel-Event       | 鼠标滚轮在图形场景中滚动                  |
| QEvent.GraphicsSceneHelp             | 163  | QHelpEvent                      | 用户请求图形场景的帮助                    |
| QEvent.ToolTip                       | 110  | QHelpEvent                      | #NAME?                                    |
| QEvent.WhatsThis                     | 111  | QHelpEvent                      | 控件显示"What'sThis"帮助                  |
| QEvent.Hide                          | 18   | QHideEvent                      | 控件被隐藏                                |
| QEvent.HideToParent                  | 27   | QHideEvent                      | 子控件被隐藏                              |
| QEvent.HoverEnter                    | 127  | QHoverEvent                     | 光标进入悬停控件                          |
| QEvent.HoverLeave                    | 128  | QHoverEvent                     | 光标离开悬停控件                          |
| QEvent.HoverMove                     | 129  | QHoverEvent                     | 光标在悬停控件内移动                      |
| QEvent.IconDrag                      | 96   | QIconDragEvent                  | 窗口的主图标被拖走                        |
| QEvent.InputMethod                   | 83   | QInputMethodEvent               | 正在使用输人法                            |
| QEvent.InputMethodQuery              | 207  | QInputMethodQuery-Event         | 输人法查询事件                            |
| QEvent.KeyPress                      | 6    | QKeyEvent                       | 键盘按下                                  |
| QEvent.KeyRelease                    | 7    | QKeyEvent                       | 键盘释放                                  |
| QEvent.ShortcutOverride              | 51   | QKeyEvent                       | 按下按键.用于覆盖快捷键                   |
| QEvent.MouseButtonDblClick           | 4    | QMouseEvent                     | 鼠标再次按下                              |
| QEvent.MouseButtonPress              | 2    | QMouseEvent                     | 鼠标按下                                  |
| QEvent.MouseButtonRelease            | 3    | QMouseEvent                     | 鼠标释放                                  |
| QEvent.MouseMove                     | 5    | QMouseEvent                     | 鼠标移动                                  |
| QEvent.Move                          | 13   | QMoveEvent                      | 控件的位置发生改变                        |
| QEvent.NativeGesture                 | 197  | QNativeGestureEvent             | 系统检测到手势                            |
| QEvent.Paint                         | 12   | QPaintEvent                     | 需要屏幕更新                              |
| QEvent.Resize                        | 14   | QResizeEvent                    | 控件的大小发生改变                        |
| QEvent.Scroll                        | 205  | QScrollEvent                    | 对象需要滚动到提供的位置                  |
| QEvent.ScrollPrepare                 | 204  | QScrollPrepareEvent             | 对象需要填充它的几何信息                  |
| QEvent.Shortcut                      | 117  | QShortcutEvent                  | 快捷键处理                                |
| QEvent.Show                          | 17   | QShowEvent                      | 控件显示在屏幕上                          |
| QEvent.StatusTip                     | 112  | QStatusTipEvent                 | 状态提示请求                              |
| QEvent.TabletMove                    | 87   | QTabletEvent                    | Wacom写字板移动                           |
| QEvent.TabletPress                   | 92   | QTabletEvent                    | Wacom写字板按下                           |
| QEvent.TabletRelease                 | 93   | QTabletEvent                    | Wacom写字板释放                           |
| QEvent.Timer                         | 1    | QTimerEvent                     | 定时器事件                                |
| QEvent.TouchBegin                    | 194  | QTouchEvent                     | 触摸屏或轨迹板序列的开始                  |
| QEvent.TouchCancel                   | 209  | QTouchEvent                     | 取消触摸事件序列                          |
| QEvent.TouchEnd                      | 196  | QTouchEvent                     | 触摸事件序列结束                          |
| QEvent.TouchUpdate                   | 195  | QTouchEvent                     | 触摸屏事件                                |
| QEvent.Wheel                         | 31   | QWheelEvent                     | 鼠标滚轮滚动                              |
| QEvent.WindowStateChange             | 105  | QWindowStateChangeEvent         | 窗口的状态(最小化、最大化或全屏)发生改变  |



### event()函数

当GUI应用程序捕捉到事件发生后,会首先将其发送到 QWidget 或子类的event(QEvent)函数中进行数据处理,如果没有重写event()函数进行事件处,理事件将会分发到事件默认的处理函数中,因此event()函数是事件的集散地。

如果重写了 event()函数当event()函数的返回值是True 时,表示事件已经处理完毕事件不会再发送给其他处理函数;当event()函数的返回值是 False时,表示事件还没有处理完毕。event()函数可以截获某些类型的事件,并处理事件

下面的程序是将上节中的例子做了改动将鼠标的单击事件放到event()函数中进行处理,只截获QEvent.MouseButtonPress事件,通过 super()函数调用父类的 event()函数其他类型的事件仍交由QWidget 的event()函数处理和分发。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 21:18
# File_name: 02-event()函数.py
import sys
from PySide6.QtWidgets import QApplication, QWidget, QLineEdit
from PySide6.QtCore import QEvent, Qt


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.resize(500, 500)
        self.lineEdit = QLineEdit(self)
        self.lineEdit.setGeometry(0, 0, 500, 30)

    def event(self, even):  # 重写event函数
        if even.type() == QEvent.MouseButtonPress:  # 按键的情况
            template1 = "单击点的窗口坐标是x:{} y:{}"
            template2 = "单击点的屏幕坐标是x:{} y:{}"

            if even.button() == Qt.LeftButton:  # button()获取键或右键
                string = template1.format(even.position().x(), even.position().y())  # x()和()获取窗口坐标
                self.lineEdit.setText(string)
                return True

            elif even.button() == Qt.RightButton:  # globalX()和globalY()获取全局坐标
                string = template2.format(even.globalPosition().x(), even.globalPosition().y())
                self.lineEdit.setText(string)
                return True

            else:  # 按中键的情况
                return True

        else:  # 对于不是按鼠标键的事件,交给 owidget 来处理
            finished = super().event(even)  # super()函数调用父类丽数
            return finished


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 常用事件的处理函数

窗口或控件中用于常用事件的处理函数及参数类型如表所示,传递的参数是对应类的实例对象,参数所代表的类的使用方法在后续内容中进行介绍

| 常用事件的处理函数及参数类型        | 说 明                                                        |
| ----------------------------------- | ------------------------------------------------------------ |
| actionEvent(QActionEvent)           | 当增加、插人、删除QAction时调用该函数                        |
| changeEvent(QEvent)                 | 状态发生改变时调用该函数,事件类型包括:<br />QEvent.ToolBarChange、QEvent.ActivationChange、QEvent.EnabledChange、 QEvent.FontChange、QEvent.StyleChange、QEvent.PaletteChange、 QEvent.WindowTitleChange、QEvent.IconTextChange、QEvent.ModifiedChange、QEvent.MouseTrackingChange、QEvent.ParentChange、 QEvent.WindowStateChange、QEvent.LanguageChange、QEvent.LocaleChange、QEvent.LayoutDirectionChange、QEvent.ReadOnlyChange |
| childEvent(QChildEvent)             | 容器控件中添加或移除控件时调用该函数                         |
| closeEvent(QCloseEvent)             | 关闭窗口时调用该函数                                         |
| contextMenuEvent(QContextMenuEvent) | 当窗口或控件的contextMenuPolicy 属性值是 Qt.DefaultContextMenu,单击右键弹出右键菜单时调用该函数 |
| dragEnterEvent(QDragEnterEvent)     | 用鼠标拖拽物体进入窗口或控件时调用该函数                     |
| dragLeaveEvent(QDragLeaveEvent)     | 用鼠标拖拽物体离开窗口或控件时调用该函数                     |
| dragMoveEvent(QDragMoveEvent)       | 用鼠标拖拽物体在窗口或控件中移动时调用该函数                 |
| dropEvent(QDropEvent)               | 用鼠标拖拽物体在窗口或控件中释放时调用该函数                 |
| enterEvent(QEnterEvent)             | 光标进人窗口或控件时调用该函数                               |
| focusInEvent(QFocusEvent)           | 用键盘使窗口或控件获得焦点时调用该函数                       |
| focusOutEvent(QFocusEvent)          | 用键盘使窗口或控件失去焦点时调用该函数                       |
| hideEvent(QHideEvent)               | 隐藏或最小化窗口时调用该函数                                 |
| inputMethodEvent(QInputMethodEvent) | 输人方法的状态发生改变时调用该数                             |
| keyPressEvent(QKeyEvent)            | 按下键盘的按键时调用该函数                                   |
| keyReleaseEvent(QKeyEvent)          | 释放键盘的按键时调用该函数                                   |
| leaveEvent(QEvent)                  | 光标离开窗口或控件时调用该函数                               |
| mouseDoubleClickEvent(QMouseEvent)  | 双击鼠标时调用该函数                                         |
| mouseMoveEvent(QMouseEvent)         | 光标在窗口或控件中移动时调用该函数                           |
| mousePressEvent(QMouseEvent)        | 按下鼠标的按键时调用该函数                                   |
| mouseReleaseEvent(QMouseEvent)      | 释放鼠标的按键时调用该函数                                   |
| moveEvent(QMoveEvent)               | 移动窗口或控件时调用该函数                                   |
| paintEvent(QPaintEvent)             | 控件或窗口需要重新绘制时调用该函数                           |
| resizeEvent(QResizeEvent)           | 窗口或控件的尺寸(长度或宽度)发生改变时调用该函数             |
| showEvent(QShowEvent)               | 显示窗口或从最小化恢复到原窗口状态时调用该函数 .             |
| tabletEvent(QTabletEvent)           | 平板电脑处理事件                                             |
| timerEvent(QTimerEvent)             | 用窗口或控件的 startTimer(interval: int, timerType:Qt.CoarseTimer)方法启动一个定时器时调用该函数 |
| wheelEvent(QWheelEvent)             | 转动鼠标的滚轮时调用该函数                                   |







每个窗口或控件的功能是不同的,因此窗口和控件的事件也不同,用于处理事件的函数也不同。

下面介绍的窗口或常用控件的事件处理函数如表所示。要调用窗口或控件的事件处理函数,需要继承窗口类或控件类创建其子类,在子类中重写事件处理函数。

| 窗口或控件      | 窗口或控件的事件处理函数                                     |
| --------------- | ------------------------------------------------------------ |
| QWidget         | actionEvent()<br />changeEvent()<br />closeEvent()<br />contextMenuEvent()<br />dragEnterEvent()<br />dragLeaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />enterEvent()<br />focusInEvent()<br />focusOutEvent()<br />hideEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />leaveEvent()<br />keyReleaseEvent()<br />mouseDoubleClickEvent()<br />mouseMoveEvent()<br />showEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />moveEvent()<br />paintEvent()<br />event()resizeEvent()<br />tabletEvent()<br />wheelEvent() |
| QMainWindo      | contextMenuEvent()<br />event()                              |
| QDialog         | showEvent()<br />closeEvent()<br />contextMenuEvent()<br />eventFilter()<br />keyPressEvent()<br />resizeEvent() |
| QLabel          | changeEvent()<br />contextMenuEvent()<br />event()<br />focusInEvent()<br />focusutEvent()<br />keyPressEyent()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEyent() |
| QLineEdit       | changeEvent()<br />contextMenuEvent()<br />dragEnterEvent()<br />dragleaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />focusInEvent()<br />focusutEvent()<br />paintEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />mouseMoveEvent()<br />mouseDoubleClickEvent()<br />mousePressEvent()<br />rouseReleaseEvent() |
| QTextEdit       | changeEvent()<br />contextMenuEvent()<br />dragEnterEvent()<br />dragLeaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />focusInEvent()<br />focusCutEvent()<br />showEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />resizeEvent()<br />mouseDoubleClickEvent()<br />mouseMoyeEvent()<br />mousePressEvent()<br />paintEvent()<br />mouseReleaseEvent()<br />wheelEvent() |
| QPlainTextEdit  | changeEvent()<br />contextMenuEvent()<br />dragEnterEvent()<br />dragLeaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />focusInEvent()<br />focusOutEvent()<br />paintEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />resizeEvent()<br />mouseDoubleClickEvent()<br />mouseMoveEvent()<br />mousePressEvent()<br />showEvent()<br />mouseReleaseEvent()<br />wheelEvent() |
| QTextBrowser    | event()<br />focusOutEvent()<br />keyPressEvent()<br />mouseMoveEvent()<br />paintEvent()<br />mousePressEvent()<br />mouseReleaseEvent() |
| QComboBox       | changeEvent()<br />contextMenuEvent()<br />focusInEvent()<br />focusOutEvent()<br />hideEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />musePressEvent()<br />mouseReleaseEvent()<br />paintEvent()<br />resizeEvent()<br />showEvent()<br />wheelEvent() |
| QScrollBar      | event()<br />contextMenuEvent()<br />hideEvent()<br />mouseMoveEvent()<br />paintEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />wheelEvent() |
| QSlider         | event()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent() |
| QDial           | event()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent()<br />resizeEvent() |
| QProgressBar    | event()<br />paintEvent()                                    |
| QPushButton     | event()<br />focusInEvent()<br />focusOutEvent()<br />keyPressEvent()<br />mouseMoveEvent()<br />paintEvent() |
| QCheckBox       | event()<br />mouseMoveEvent()<br />paintEvent()              |
| QRadioButton    | event()<br />mouseMoveEvent()<br />paintEvent()              |
| OCalendarWidget | event()<br />eventFilter(t)<br />keyPressEvent()<br />mousePressEvent()<br />resizeEvent() |
| QLCDNumber      | event()<br />paintEvent()                                    |
| QDateTimeEdit   | focusInEvent()<br />keyPressEvent()<br />mousePressEvent()<br />paintEvent()<br />wheelEvent() |
| QGroupBox       | changeEvent()<br />childEvent(QChildEvent)<br />event()<br />focusInEvent()<br />resizeEvent()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent() |
| QFrame          | changeEvent()<br />event()<br />paintEvent()                 |
| QScrollArea     | event()<br />eventFilter(QObject,<br />QEvent)<br />resizeEvent() |
| QTabWidget      | changeEvent()<br />event()<br />keyPressEvent()<br />paintEvent()<br />resizeEvent()<br />showEvent() |
| QToolBox        | changeEvent()<br />closeEvent()<br />event()<br />paintEvent() |
| QSplitter       | childEvent(QChildEvent)<br />event()<br />eventFilter()<br />paintEvent()<br />resizeEvent()<br />showEvent()<br />timerEvent()<br />viewportEvent() |
| QWebEngineView  | closeEvent()<br />contextMenuEvent()<br />dragEnterEvent()<br />dragLeaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />event()<br />hideEvent()<br />showEvent() |
| QDockWidget     | changeEvent()<br />closeEvent()<br />event()<br />paintEvent() |
| QMdiArea        | childEvent(QChildEvent)<br />event()<br />eventFilter()<br />paintEvent()<br />resizeEvent()<br />showEvent()<br />timerEvent()<br />viewportEvent() |
| QMdiSubWindow   | changeEvent()<br />childEvent(QChildEvent)<br />closeEvent()<br />contextMenuEvent()<br />event()<br />eventFilter()<br />focusInEvent()<br />focusOutEvent()<br />hideEvent()<br />timerEvent()<br />keyPressEvent()<br />leaveEvent()<br />mouseDoubleClickEvent()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />moveEvent()<br />paintEvent()<br />resizeEvent()showEvent() |
| QToolButton     | actionEvent()<br />changeEvent()<br />enterEvent()<br />event()<br />leaveEvent()<br />timerEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent() |
| QToolBar        | actionEvent()<br />changeEvent()<br />event()<br />paintEvent() |
| QMenuBar        | actionEvent()<br />changeEvent()<br />event()<br />eventFilter()<br />focusnEvent()<br />leaveEvent()<br />focusOutEvent()<br />keyPressEvent()<br />nouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent()<br />resizeEvent()<br />timerEvent(QTimerEvent) |
| QStatusBar      | event()<br />paintEvent()<br />resizeEvent()<br />showEvent() |
| QTabBar         | changeEvent()event()<br />hideEvent()<br />keyPressEvent()<br />mouseDoubleClickEvent()<br />mouseMoveEvent()<br />mousePressEyent()<br />ouseReleaseEvent()<br />paintEyent()<br />resizeEvent()<br />showEvent()<br />timerEyent(QTimerEvent)<br />wheelEvent() |
| QListWidget     | dropEvent()<br />event()                                     |
| QTableWidget    | dropEvent()<br />event()                                     |
| QTreeWidget     | dropEvent()<br />event()                                     |
| QListView       | dragLeaveEvent()<br />dragMoveEvent()<br />dropEvent()<br />event()<br />mouseMoveEvent()<br />mouseReleaseEvent()<br />paintEvent()<br />resizeEvent()<br />timerEvent(QTimerEvent)<br />wheelEvent() |
| QTreeView       | changeEvent()<br />dragMoveEvent()<br />keyPressEvent()<br />mouseDoubleClickEvent()<br />mouseMoveEvent()<br />mousePressEvent()<br />mouseReleaseEvent()<br />paintEvent()<br />timerEvent(QTimerEvent)<br />viewportEvent() |
| QTableView      | paintEyent()<br />timerEvent(QTimerEvent)                    |
| QVideoWidget    | event()<br />hideEvent()<br />moveEvent()<br />resizeEvent()<br />showEvent() |
| QGraphicsView   | contextMenuEvent()<br />dragEnterEvent()<br />dragLeaveEvent()<br />ragMoveEvent()<br />dropEvent()<br />event()<br />focusInEvent()<br />focusOutEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />mouseDoubleClickEvent()<br />paintEvent()<br />mouseMoveEyent()<br />mousePressEyent()<br />mouseReleaseEvent()<br />resizeEvent()<br />showEvent()<br />viewportEvent()<br />wheelEvent() |
| QGraphicsScene  | event()<br />focusInEyent()<br />focusOutEvent()<br />keyPressEvent()<br />keyReleaseEvent()<br />eventFilter(QObject,<br />QEvent)<br />inputMethodEvent()<br />helpEvent(QGraphicsSceneHelpEvent)<br />wheelEvent(QGraphicsSceneWheelEvent)<br />contextMenuEvent(QGraphicsSceneContextMenuEvent)<br />dragEnterEyent(QGraphicsSceneragDropEvent)<br />dragleaveEvent(QGraphicsSceneDragDropEvent)<br />dragMoveEvent(QGraphicsSceneDragDropEvent)<br />dropEvent(QGraphicsSceneDragDropEvent)<br />mouseDoubleClickEvent(QCraphicsSceneMouseEvent)<br />mouseMoveEvent(QGraphicsSceneMouseEvent)<br />mousePressEvent(QGraphicsSceneMouseEvent)<br />mouseReleaseEvent(QGraphicsSceneMouseEvent) |
| QGraphicsWidget | changeEyent()<br />closeEvent()<br />hideEvent()<br />showEvent()<br />polishEvent()<br />grabKeyboardEvent(QEvent)<br />grabMouseEvent(QEvent)<br />ungrabKeyboardEventQEvent)<br />ungrabMouseEvent(QEvent)<br />windowFrameEvent(QEvent)<br />moveEventQGraphicsSceneMoveEvent)<br />rasizeEvent(QGraphicsSceneResizeEvent) |
| QGraphicsItem   | focusInEvent()<br />focusOutEvent()<br />inputMethodEvent()<br />keyPressEvent()<br />QEvent()<br />keyReleaseEvent()<br />sceneEvent()<br />dropEvent(QGraphicsSceneDragDropEvent)<br />sceneEventFilter(QGraphicsItem,<br />QEvent)<br />wheelEvent(QGraphicsSceneWheelEvent)<br />contextMenuEvent(QGraphicsSceneContextMenuEvent)<br />dragEnterEvent(QGraphicsSceneDragDropEvent)<br />dragLeaveEvent(QGraphicsSceneDragDropEvent)<br />dragMoveEvent(QGraphicsSceneDragDropEvent)<br />hoverEnterEvent(QGraphicsSceneHoverEvent)<br />hoverLeaveEvent(QGraphicsSceneHoverEvent)<br />hoverMoveEvent(QGraphicsSceneHoverEvent)<br />mouseDoubleClickEvent(GraphicsSceneMouseEvent)<br />mouseMoveEvent(QGraphicsSceneMouseEvent)<br />mousePressEvent(QGraphics-SceneMouseEvent)<br />mouseReleaseEvent(QGraphicsSceneMoGseEvent) |

## 鼠标事件和键盘事件

鼠标事件和键盘事件是用得最多的事件,通过鼠标和键盘事件可以拖拽控件、弹出快捷菜单等。

### 鼠标事件QMouseEvent和滚轮事件QWheelEvent 

鼠标事件类QMouseEvent涉及鼠标按键的单击释放和鼠标移动操作与QMouseEvent关联的事件类型有:

- QEvent.MouseButtonDblClick
- QEvent.MouseButtonPress
- QEvent.MouseButtonRelease
- QEvent.MouseMove

当在一个窗口或控件中按住鼠标按键或释放按键时会产生鼠标事件QMouseEvent

鼠标移动事件只会在按下鼠标按键的情况下才会发生,除非通过显式调用窗口的 setMouseTracking(True)函数来开启鼠标轨迹跟踪,这种情况下只要鼠标指针移动,就会产生一系列鼠标事件。

处理QMouseEvent类鼠标事件的函数有:

- mouseDoubleClickEvent(QMouseEvent)(双击鼠标按键)
- mouseMoveEvent(QMouseEvent)(移动鼠标)
- mousePressEvent(QMouseEvent)(按下鼠标按键)
- mouseReleaseEvent(QMouseEvent)(释放鼠标按键)。

鼠标滚轮的滚动事件类是QWheelEvent,处理QWheelEvent 滚轮事件的函数是 wheelEvent(QWheelEvent)。

#### 鼠标事件QMouseEvent 的常用方法

当产生鼠标事件时,会生成 QMouseEvent 类的实例对象,并将实例对象作为实参传递给相关的处理函数。

QMouseEvent 类包含了用于描述鼠标事件的参数。

QMouseEvent类在 QtGui模块中,它的常用方法如表 4-5所示,主要方法介绍如下。

- 用button()方法可以获取产生鼠标事件的按键,用buttons()方法获取产生鼠标事件时被按住的按键,返回值可以是: 
  - Qt.NoButton
  - Qt.AllButtons
  - Qt.LeftButton
  - Qt.RightButton
  - Qt.MidButton
  - Qt.MiddleButton
  - Qt.BackButton
  - Qt.ForwardButton
  - Qt.TaskButton
  - Qt.ExtraButtoni(i=1,2,...,24)
- 用source()方法可以获取鼠标事件的来源,返回值可以是:
  - Qt.MouseEventNotSynthesized(来自鼠标)
  - Qt.MouseEventSynthesizedBySystem(来自鼠标和触摸)
  - Qt.MouseEventSynthesizedByQt(来自触摸屏)
  - Qt.MouseEventSynthesizedByApplication(来自应用程序)
- 产生鼠标事件的同时,有可能按下了键盘上的 Ctrl Shift 或 Alt 等修饰键,用modifiers()方法可以获取这些键。modifiers()方法的返回值可以是:
  - Qt.NoModifier(没有修饰键)
  - Qt.ShiftModifier(Shift 键)
  - Qt.ControlModifier(Ctrl键)
  - Qt.AltModifier(Alt 键)
  - Qt.MetaModifier(Meta 键,Windows 系统为 window键)
  - Qt.KeypadModifier(小键盘上的键)
  - Qt.GroupSwitchModifier(Modeswitch 键)

- 用deviceType()方法可以获取产生鼠标事件的设备类型,返回值是 QInputDevice.DeviceType 的枚举值可取:
  - QInputDevice.Unknown
  - QInputDevice.Mouse
  - QInputDevice.TouchScreen 
  - QInputDevice.TouchPad 
  - QInputDevice.Stylus
  - QInputDevice.Airbrush
  - QInputDevice.Puck
  - QInputDevice.Keyboard
  - QInputDevice.AlDevices(以上设备中的任意一种)。
- 用flags()方法可以识别产生鼠标事件时的标识,返回值是 QtMouseEventFlags的枚举值,只可以取Qt.MouseEventCreatedDoubleClick,用于标识鼠标的双击事件



| QMouseEvent的方法 | 返回值的类型            | 说 明                                                        |
| ----------------- | ----------------------- | ------------------------------------------------------------ |
| button()          | Qt.MouseButton          | 获取产生鼠标事件的按键                                       |
| buttons()         | Qt.MouseButtons         | 获取产生鼠标事件时被按下的按键                               |
| flags()           | Qt.MouseEventFlags      | 获取鼠标事件的标识                                           |
| source()          | Qt.MouseEventSource     | 获取鼠标事件的来源                                           |
| modifiers()       | Qt.KeyboardModifiers    | 获取修饰键                                                   |
| device()          | QInputDevice            | 获取产生鼠标事件的设备                                       |
| deviceType()      | QInputDevice.DeviceType | 获取产生鼠标事件的设备类型                                   |
| globalPos()       | QPoint                  | 获取全局的鼠标位置                                           |
| globalX()         | int                     | 获取全局的X坐标                                              |
| globalY()         | int                     | 获取全局的Y坐标                                              |
| localPos()        | QPointF                 | 获取局部鼠标位置                                             |
| screenPos()       | QPointF                 | 获取屏幕的鼠标位置                                           |
| windowPos()       | QPointF                 | 获取相对于接受事件窗口的鼠标位置                             |
| pos()             | QPoint                  | 获取相对于控件的鼠标位置<br />此方法在新版本已经会发出弃用警告改用position() |
| position()        | QPoint                  | 获取相对于控件的鼠标位置                                     |
| x()               | int                     | 获取相对于控件的X坐标<br />此方法在新版本已经会发出弃用警告改用position().x() |
| y()               | int                     | 获取相对于控件的Y坐标<br />此方法在新版本已经会发出弃用警告改用position().y() |

#### 滚轮事件QWheelEvent的方法

滚轮事件 QWheelEvent类处理鼠标的滚轮事件,其常用方法如表所示大部分方法与QMouseEvent 的方法相同,主要不同的方法如下所述。

- 滚轮角度

  - angleDelta().y()返回两次事件之间鼠标竖直滚轮旋转的角度

  - angleDelta()x()返回两次事件之间鼠标水平滚轮旋转的角度。

  - 如果没有水平滚轮,则angleDetal().x()的值为 0,正数值表示滚轮相对于用户在向前滑动,负数值表示滚轮相对于用户在向后滑动

- pixelDelta()方法返回两次事件之间控件在屏幕上的移动距离(单位是像素)

- inverted()方法将 angleDelta()和 pixelDelta()的值与滚轮转之间的取值关系反向,即正数值表示滑轮相对于用户在向后滑动,负数值表示滑轮相对于用户在向前滑动。

- phase()方法返回设备的状态,返回值有:

  - Qt.NoScrollPhase(不支持滚动)
  - Qt.ScrollBegin(开始位置)
  - Qt.ScrollUpdate(处于滚动状态)
  - Qt.ScrollEnd(结束位置)
  - Qt.ScrollMomentum(不触碰设备,由于惯性仍处于滚动状态)

| QWheelEvent的方法 | 返回值的类型            |
| ----------------- | ----------------------- |
| angleDelta()      | QPoint                  |
| pixelDelta()      | QPoint                  |
| phase()           | Qt.ScrollPhase          |
| inverted()        | bool                    |
| source()          | Qt.MouseEventSource     |
| buttons()         | Qt.MouseButtons         |
| globalPos()       | QPoint                  |
| globalPosF()      | QPointF                 |
| deviceType()      | QInputDevice.DeviceType |
| modifiers()       | Qt.KeyboardModifiers\|  |
| globalPosition()  | QPointF                 |
| globalX()         | int                     |
| globalY()         | int                     |
| pos()             | QPoint                  |
| posF()            | QPointF                 |
| position()        | QPointF                 |
| x()               | int                     |
| y()               | int                     |

#### QMouseEvent 类和QWheelEvent 类的应用实例

下面的程序涉及鼠标单击、拖拽、双击和滚轮滚动的事件

双击窗口的空白处或者单击菜单,弹出打开图片的对话框,选择图片后,显示出图片

按住 Ctrl 键和鼠标左键并拖动鼠标可以移动图片,按住 Ctrl键并滚动滚轮可以缩放图片。

程序中通过控制绘图区域的中心位置来移动图像,通过控制图像区域的宽度和高度来缩放图像。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 23:00
# File_name: 01-鼠标事件QMouseEvent和滚轮事件QWheelEvent .py
from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenuBar
from PySide6.QtGui import QPixmap, QPainter, QMouseEvent, QWheelEvent
from PySide6.QtCore import QRect, QPoint, Qt.QPointF
import sys


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.resize(600, 600)
        self.pixmap = QPixmap()  # 创建QPixmap图像
        self.pix_width = 0  # 获取初始宽度
        self.pix_height = 0  # 获取初始高度
        self.translate_x = 0  # 用于控制x向平移
        self.translate_y = 0  # 并用于控制y向平移
        self.pixmap_scal_x = 0  # 用于记录图像的长度比例,用于图像缩放
        self.pixmap_scal_y = 0  # 用于记录图像的高度比例,用于图像缩放
        self.start = QPoint(0, 0)  # 鼠标单击时光标位置

        # 记录图像中心的变量,初始定义在窗口的中心
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))
        menuBar = QMenuBar(self)
        menuFile = menuBar.addMenu("文件(&F)")
        menuFile.addAction("打开(&0)").triggered.connect(self.actionOpen_triggered)
        menuFile.addSeparator()
        menuFile.addAction("退出(&E)").triggered.connect(self.close)  # 动作与槽连接

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        self.center = QPoint(self.center.x() + self.translate_x, self.center.y() + self.translate_y)

        # 图像绘制区域的左上角点,用于缩放图像
        point_1 = QPoint(self.center.x() - self.pix_width, self.center.y() - self.pix_height)

        # 图像绘制区域的右下角点,用于缩放图像
        point_2 = QPoint(self.center.x() + self.pix_width, self.center.y() + self.pix_height)

        self.rect = QRect(point_1, point_2)  # 图像绘制区域
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect, self.pixmap)

    def mousePressEvent(self, event: QMouseEvent):  # 鼠标按键按下事件的处理函数
        self.start: QPointF = event.position()  # 鼠标位置
        # 这里在Qt6使用pos()会发出弃用警告官方建议的是用position()代替pos()

    def mouseMoveEvent(self, event: QMouseEvent) -> None:  # 鼠标移动事件的处理函数
        if event.modifiers() == Qt.ControlModifier and event.buttons() == Qt.LeftButton:
            # 这里直接从event获取坐标会发出弃用警告,官方建议的是用position()间接获得坐标
            self.translate_x = event.position().x() - self.start.x()  # 鼠标的移动量
            self.translate_y = event.position().y() - self.start.y()

            self.start = event.position()
            self.update()  # 会调用paintEvent()

    def wheelEvent(self, event: QWheelEvent) -> None:  # 鼠标滚轮事件的处理函数
        if event.modifiers() == Qt.ControlModifier:
            if(self.pix_width > 10 and self.pix_height > 10) or event.angleDelta().y() > 0:
                self.pix_width = self.pix_width + int(event.angleDelta().y() / 10 * self.pixmap_scal_x)
                self.pix_height = self.pix_height + int(event.angleDelta().y() / 10 * self.pixmap_scal_y)

                self.update()

    def mouseDoubleClickEvent(self, event):  # 双击鼠标事件的处理函数
        self.actionOpen_triggered()

    def actionOpen_triggered(self):  # 打开文件动作
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *.jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)

        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽高
            self.pix_height = int(self.pixmap.height() / 2)

            self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
            self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
            self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

            self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```



### 键盘事件QKeyEvent

键盘事件QKeyEvent 涉及键盘键的按下和释放与QKeyEvent 关联的事件类型有:

> - QEvent.KeyPress
> - QEvent.KeyRelease 
> - QEvent.ShortcutOverride

处理键盘事件的函数是 keyPressEvent(QKeyEvent)和 keyReleaseEvent(QKeyEvent)。

- 当发生键盘事件时将创建QKeyEvent的实例对象,并将实例对象作为实参传递给处理函数键盘事件QKeyEvent的常用方法如所示主要方法介绍如下:
  - 如果同时按下多个键,可以用count()方法获取按键的数量。
  - 如果按下一个键不放,将连续触发键盘事件,用isAutoRepeat()方法可以获取某个事件是否是重复事件。
  - 用key()方法可以获取按键的Qtkey代码值不区分大小写;可以用text()方法获取按键的字符,区分大小写。
  - 用matches(QKeySequenceStandardKey)方法可以判断按下的键是否匹配标准的按键,QKeySequenceStandardKey中定义了常规的标准按键例如:
    - Ctrl+C表示复制、Ctrl+V表示粘贴、Ctrl+S表示保存Ctrl+0表示打开Ctrl+w或Ctrl+F4表示关闭。

| QKeyEvent的方法                   | 返回值的类型         | 说明                                |
| --------------------------------- | -------------------- | ----------------------------------- |
| count()                           | int                  | 获取按键的数量                      |
| isAutoRepeat()                    | bool                 | 获取是否是重复事件                  |
| key()                             | int                  | 获取按键的代码                      |
| matches(QKeySequence.StandardKey) | bool                 | 如果按键匹配标准的按键,则返 回 True |
| modifiers()                       | Qt.KeyboardModifiers | 获取修饰键                          |
| text()                            | Str                  | 返回按键上的字符                    |

### 鼠标拖放事件QDropEvent和QDragMoveEvent 

可视化开发中经常会用鼠标拖放动作来完成一些操作,例如把一个 docx 文档拖到Word 中直接打开,把图片拖放到一个图片浏览器中打开,拖放一段文字到其他位置等。

拖放事件包括鼠标进人、鼠标移动和鼠标释放事件,还可以有鼠标移出事件,对应的事件类型分别是:

- QEvent.DragEnter
- QEvent.DragMove 
- QEvent.Drop 
- QEvent.DragLeave。

拖放事件类分别为QDragEnterEvent,QDragMoveEvent,QDropEvent和QDragLeaveEvent,其实例对象中保存着拖放信息,例如被拖放文件路径、被拖放的文本等。拖放事件的处理函数分别是:

- dragEnterEvent(QDragEnterEvent)
- dragMoveEvent(QDragMoveEvent)
- dropEvent(QDropEvent)
- dragLeaveEvent(QDragLeaveEvent)

#### QDropEvent 和 QDragMoveEvent 的方法

QDragEnterEvent类是从QDropEvent类和QDragMoveEvent 类继承而来的,它没有自己特有的方法;

QDragMoveEvent 类是从QDropEvent 类继承而来的,它继承了QDropEvent类的方法,又添加了自已新的方法;

QDragLeaveEvent类是从QEvent类继承而来的,它也没有自己特有的方法。



QDropEvent类和QDragMoveEvent类的方法分别如表所示,主要方法介绍如下。

- 使一个控件或窗口接受拖放
  - 必须用setAcceptDrops(True)方法设置成接受拖放,
  - 在进入事件的处理函数 dragEnterEvent(QDragEnterEvent)中,需要把事件对象设置成 accept(),否则无法接受后续的移动和释放事件
- 在拖放事件中用mimeData()方法获取被拖放物体的QMimeData 数据MIME(multipurposeinternet mail extensions)是多用途互联网邮件扩展类型。关于QMimeData的介绍参见下面的内容。
- 在释放动作中,被拖拽的物体可以从原控件中被复制或移动到目标控件中
  - 复制或移动动作可以通过 setDropAction(QtDropAction)方法来设置其中Qt.DropAction可以取:
    - Qt.CopyAction(复制)
    - Qt.MoveAction(移动)
    - Qt.LinkAction(链接)
    - Qt.IgnoreAction(什么都不做)
    - Qt.TargetMoveAction(目标对象接管)
  - 另外系统也会推荐一个动作,可以用proposedAction()方法获取推荐的动作,用possibleActions()方法获取有可能实现的动作用dropAction()方法获取采取的动作。

**QDropEvent的常用方法**

| QDropEvent 的方法            | 返回值的类型         | 说明               |
| ---------------------------- | -------------------- | ------------------ |
| keyboardModifiers()          | Qt.KeyboardModifiers | 获取修饰键         |
| mimeData()                   | QMimeData            | 获取 mime 数据     |
| mouseButtons()               | Qt.MouseButtons      | 获取按下的鼠标按键 |
| pos()                        | QPoint               | 获取释放时的位置   |
| posF()                       | QPointF              | 获取释放时的位置   |
| dropAction()                 | Qt.DropAction        | 获取采取的动作     |
| possibleActions()            | Qt.DropActions       | 获取可能实现的动作 |
| proposedAction()             | Qt.DropAction        | 系统推荐的动作     |
| acceptProposedAction()       | None                 | 接受推荐的动作     |
| setDropAction(Qt.DropAction) | None                 | 设置释放动作       |
| source()                     | QObject              | 获取被拖对象       |

**QDragMoveEvenl的常用方法**

| QDragMoveEvent的方法 | 返回值的类型 | 说 ,明                               |
| -------------------- | ------------ | ------------------------------------ |
| accept()             | None         | 在控件或窗口的边界内都可接受移动事件 |
| accept(QRect)        | None         | 在指定的区域内接受移动事件           |
| ignore()             | None         | 在整个边界内部忽略移动事件           |
| ignore(QRect)        | None         | 在指定的区域内部忽略移动事件         |
| answerRect()         | QRect        | 返回可以释放的区域                   |

#### QMimeData类

QMimeData 类用于描述存放到粘贴板上的数据,并通过拖放事件传递粘贴板上的数据,从而在不同的程序间传递数据,也可以在同一个程序内传递数据。

创建 QMimeData 实例对象的方法是 QMimeData(),它在 QtCore模块中。QMimeData 可以存储的数据有文本、图像、颜色和地址等。

QMimeData类的方法如表所示,可以分项设置和获取数据,也可以用setData(str,QByteArray)方法设置数据

QMimeData的数据格式各种数据设置和获取的方法如表所示。

**QMimeData类的方法**

| QMimeData的方法及参数类型 | 返回值的类型 | 说明                |
| ------------------------- | ------------ | ------------------- |
| formats()                 | List[str]    | 获取格式列表        |
| hasFormat(str)            | bo0l         | 获取是否有某种格式  |
| removeFormat(str)         | None         | 移除格式            |
| setColorData(Any)         | None         | 设置颜色数据        |
| hasColor()                | bool         | 获取是否有颜色数据  |
| colorData()               | Any          | 获取颜色数据        |
| setHtml(str)              | None         | 设置Html数据        |
| hasHtml()                 | bool         | 判断是否有 Html数据 |
| html()                    | Str          | 获取 Html数据       |
| setImageData(Any)         | None         | 设置图像数据        |
| hasImage()                | bool         | 获取是否有图像数据  |
| imageData()               | Any          | 获取图像数据        |
| setText(str)              | None         | 设置文本数据        |
| hasText()                 | bool         | 判断是否有文本数据  |
| text()                    | str          | 获取文本数据        |
| setUrls(Sequence[QUrl])   | None         | 设置Url数据         |
| hasUrls()                 | bool         | 判断是否有Url数据   |
| urls()                    | List[QUrl]   | 获取 Url数据        |
| setData(str,QByteArray)   | None         | 设置某种格式的数据  |
| data(str)                 | QByteArray   | 获取某种格式的数据  |
| clear()                   | None         | 清空格式和数据      |

**QMimeData的数据格式和方法**

| 格式                | 是否存在   | 获取方法    | 设置方法       | 举例                            |
| ------------------- | ---------- | ----------- | -------------- | ------------------------------- |
| text/plain          | hasText()  | text()      | setText()      | setText("拖动文本")             |
| text/html           | hasHtml()  | html()      | setHtml()      | setHtml("拖动文本</b>")         |
| text/uri-list       | hasUrls()  | urls()      | setUrls()      | setUrls([QUrl("www.qq.com/")])  |
| image/ *            | hasImage() | imageData() | setImageData() | setImageData(QImage("ix.png"))  |
| application/x-color | basColor() | colorData() | setColorData() | setColorData(QColor(23,56, 53)) |

#### 拖放事件的应用实例

下面的程序是在上一个实例的基础上增加了拖拽功能,除了可以双击窗口、用菜单打开二个图像文件外,也可以把一个图像文件拖拽到窗口上打开。

需要注意的是,要使窗口或控件接受拖放操作,应该用setAcceptDrops(bool)方法将其设置成 True。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:29
# File_name: demo.py

import sys
from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenuBar
from PySide6.QtGui import QPixmap, QPainter, QMouseEvent, QWheelEvent, QDragEnterEvent, QDropEvent
from PySide6.QtCore import QRect, QPoint, Qt.QPointF


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setAcceptDrops(True)  # 设置成接受拖放事件
        self.resize(600, 600)

        self.pixmap = QPixmap()  # 创建QPixmap图像
        self.pix_width = 0  # 获取初始宽度
        self.pix_height = 0  # 获取初始高度

        self.translate_x = 0  # 用于控制x向平移
        self.translate_y = 0  # 用于控制y向平移

        self.pixmap_scale_x = 0  # 用于记录图像的长度比例,用于图像缩放
        self.pixmap_scale_y = 0  # 用于记录图像的高度比例,用于图像缩放

        self.start = QPoint(0, 0)  # 鼠标单击时光标位置

        # 记录图像中心的变量,初始定义在窗口的中心
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))
        menuBar = QMenuBar(self)
        menuFile = menuBar.addMenu("文件(&F)")
        menuFile.addAction("打开(80)").triggered.connect(self.actionOpen_triggered)
        menuFile.addSeparator()
        menuFile.addAction("退出(8E)").triggered.connect(self.close)  # 动作与槽连接

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        self.center = QPoint(self.center.x() + self.translate_x, self.center.y() + self.translate_y)

        # 图像绘制区域的左上角点,用于缩放图像
        point_1 = QPoint(self.center.x() - self.pix_width, self.center.y() - self.pix_height)

        # 图像绘制区域的右下角点,用于缩放图像
        point_2 = QPoint(self.center.x() + self.pix_width, self.center.y() + self.pix_height)

        self.rect = QRect(point_1, point_2)  # 图像绘制区域
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect, self.pixmap)

    def actionOpen_triggered(self):
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *.jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)

        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽高
            self.pix_height = int(self.pixmap.height() / 2)

            self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
            self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
            self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

            self.update()

    def mousePressEvent(self, event: QMouseEvent) -> None:  # 鼠标按下事件处理
        self.start: QPointF = event.position()  # 鼠标位置
        # 这里在Qt6使用pos()会发出弃用警告官方建议的是用position()代替pos()

    def mouseMoveEvent(self, event: QMouseEvent) -> None:  # 鼠标移动事件处理
        if event.modifiers() == Qt.ControlModifier and event.buttons() == Qt.LeftButton:
            # 这里直接从event获取坐标会发出弃用警告,官方建议的是用position()间接获得坐标
            self.translate_x = event.position().x() - self.start.x()  # 鼠标的移动量
            self.translate_y = event.position().y() - self.start.y()

            self.start = event.position()
            self.update()  # 会调用paintEvent()

    def wheelEvent(self, event: QWheelEvent) -> None:  # 鼠标滚动事件
        if event.modifiers() == Qt.ControlModifier:
            if(self.pix_width > 10 and self.pix_height > 10) or event.angleDelta().y() > 0:
                self.pix_width = self.pix_width + int(event.angleDelta().y() / 3 * self.pixmap_scal_x)
                self.pix_height = self.pix_height + int(event.angleDelta().y() / 3 * self.pixmap_scal_y)

                self.update()

    def mouseDoubleClickEvent(self, event: QMouseEvent) -> None:
        self.actionOpen_triggered()

    def dragEnterEvent(self, event: QDragEnterEvent) -> None:  # 进入拖动事件
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent) -> None:  # 拖动释放事件
        urls = event.mimeData().urls()  # 获取被拖动文件的地址列表
        fileName = urls[0].toLocalFile()  # 将文件地址转成本地地址
        self.pixmap.load(fileName)
        self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽度
        self.pix_height = int(self.pixmap.height() / 2)  # 获取初始高度

        self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
        self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

        self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 拖拽类QDrag

如果要在程序内部拖放控件,需要先把控件定义成可移动控件,可移动控件需要在其内部定义 QDrag 的实例对象。

QDrag 类用于拖放物体,它继承自 QObject 类,创建 QDrag实例对象的方法是 QDrag(QObject),参数 QObject 表示只要是从 QObject 类继承的控件都可以。

#### QDrag类的方法和信号

QDrag类的方法如表所示,主要方法介绍如下:



- 创建QDrag实例对象后,用exec(supportedActions;Qt.DropActions,delaultAction;QtDropAction)或 exec(supportedActions; Qt.DropActions一Qt.MoveAction)方法开启拖放,参数是拖放事件支持的动作和默认动作,QtDropAction可以取:
  - QtCopyAction(复制数据到目标对象)
  - Qt.MoveAction(移动数据到目标对象)
  - Qt.LinkAction(在目标和原对象之间建立链接关系)
  - Qt.IgnoreAction(忽略,对数据不做任何事情)
  - QtTargetMoveAction(目标对象接管数据)
- 用setMimeData(QMimeData)方法设置mime对象,传递数据;用mimeData()方法获取mime数据
- 用setPixmap(QPixmap)方法设置拖拽时鼠标显示的图像,用setDragCursor(QPixmap,QtDropAction)方法设置拖拽时光标的形状用setHotSpot(QPoint)方法设置热点位置。热点位置是拖拽过程中,光标相对于控件左上角的位置。
- 为了防止误操作,可以用QApplication的setStartDragDistance(int)方法和setStartDragTime(msec)方法设置拖动开始一定距离或一段时间后才开始进行拖放事件。

| QDrag的方法及参数类型                                        | 返回值的类型   | 说明                             |
| ------------------------------------------------------------ | -------------- | -------------------------------- |
| exec(supportedActions: Qt.DropActions = Qt.MoveAction)       | Qt.DropAction  | 开始拖动操作,并返回释放时的 动作 |
| exec(supportedActions: Qt.DropActions, defaultAction: Qt.DropAction) |                |                                  |
| defaultAction()                                              | Qt.DropAction  | 返回默认的释放动作               |
| setDragCursor(QPixmap, Qt.DropAction)                        | None           | 设置拖拽时的光标形状             |
| dragCursor(Qt.DropAction)                                    | QPixmap        | 获取拖拽时的光标形状             |
| setHotSpot(QPoint)                                           | None           | 设置热点位置                     |
| hotSpot()                                                    | QPoint         | 获取热点位置                     |
| setMimeData(QMimeData)                                       | None           | 设置拖放中传递的数据             |
| mimeData()                                                   | QMimeData      | 获取数据                         |
| setPixmap(QPixmap)                                           | None           | 设定拖拽时鼠标显示的图像         |
| pixmap()                                                     | QPixmap        | 获取图像                         |
| source()                                                     | QObject        | 返回被拖放物体的父控件           |
| target()                                                     | QObject        | 返回目标控件                     |
| supportedActions()                                           | Qt.DropActions | 获取支持的动作                   |
| cancel()                                                     | None           | 取消拖放                         |



#### 信号

| 信号                         | 说明 |
| ---------------------------- | ---- |
| actionChanged(Qt.DropAction) |      |
| targetChanged(QObject)       |      |

#### QDrag的应用实例

下面实例先重写了QPushButton 的 mousePressEvent()事件,在该事件中定义了QDrag的实例,这样QPushButton的实例对象就是可移动控件;

然后又重新定义了QFrame框架,在内部定义了两个QPushButton,重写了dragEnterEvent()函数dragMoveEvent()函数和dropEvent()函数。

程序运行后,可以随机用鼠标左键移动按钮的位置。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 20:51
# File_name: 03-QDrag的应用实例.py
from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag, QMouseEvent
import sys
from PySide6.QtCore import QMimeData, Qt


class MyPushButton(QPushButton):
    def __init__(self, parent=None):
        super().__init__(parent)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        if event.button() == Qt.LeftButton:  # 按键事件
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()
            self.drag.setMimeData(mime)
            self.drag.exec()


class MyFame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)
        self.btn_1 = MyPushButton(self)
        self.btn_1.setText("push button 1")
        self.btn_1.move(100, 100)
        self.btn_2 = MyPushButton(self)
        self.btn_2.setText("push button 2")
        self.btn_2.move(200, 200)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())  # 获取指定位置的控件
        event.accept()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())

    def dropEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupUi(self):
        self.frame_1 = MyFame(self)
        self.frame_2 = MyFame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 上下文菜单事件QContextMenuEvent 

#### 上下文菜单事件QContextMenuEvent的方法

上下文菜单通常通过单击鼠标右键后弹出。

上下文菜单的事件类型是 QEvent.ContextMenu,处理函数是 contextMenuEvent(QContextMenuEvent),其中上下文菜单类QContextMenuEvent 的方法如表所示。主要方法介绍如下。

| QContextMenuEvent的方法 | 返回值的类型             | 说明                     |
| ----------------------- | ------------------------ | ------------------------ |
| globalPos()             | QPoint                   | 光标的全局坐标点         |
| globalX()               | int                      | 全局坐标的X值            |
| globalY()               | int                      | 全局坐标的Y值            |
| pos()                   | QPoint                   | 局部坐标点               |
| x()                     | int                      | 局部坐标的x值            |
| y()                     | int                      | 局部坐标的y值            |
| reason()                | QContextMenuEvent.Reason | 获得产生上下文菜单的原因 |
| modifiers()             | Qt.KeyboardModifiers     | 获取修饰键               |

- 用globalPos()方法、globalX()方法和 globalY()方法可以获得单击鼠标右键时的全局坐标位置

- 用pos()方法、X()方法和 y()方法可以获得窗口的局部坐标位置

- 用reason()方法可以获得产生上下文菜单的原因,返回值是 QContextMenuEvent.Reason 的枚举值,可能是:

  - QContextMenuEvent.Mouse 值为0,上下文菜单来源于鼠标
  - QContextMenuEvent.Keyboard 值为1,键盘(Windows 系统是菜单键)
  - QContextMenuEvent.Other 值为2,除鼠标及键盘之外的

- 在contextMenuEvent(QContextMenuEvent)处理函数中,用菜单的 exec(QPoint)方法在指定位置显示菜单,菜单可以是在其他位置已经定义好的,也可以是在处理函数中临时定义的。
  只有在窗口或控件的 contextMenuPlolicy 属性为Qt.DefaultContextMenu 时,单击鼠标右键才会执行处理函数,通常情况下 Qt.DefaultContextMenu是默认值。

- 如果不想弹出右键菜单,可以通过 setContextMenuPolicy(Qt.ContextMenuPolicy)方法将该属性设置为其他值,Qt.ContextMenuPolicy的取值如表所示:

  | Qt.ContextMenuPolicy 取值 | 值   | 说明                                                         |
  | ------------------------- | ---- | ------------------------------------------------------------ |
  | Qt.NoContextMenu          | 0    | 控件不具有上下文菜单,上下文菜单被推到控件的父窗口            |
  | Qt.DefaultContextMenu     | 1    | 控件或窗口的contextMenuEvent()被调用                         |
  | Qt.ActionsContextMenu     | 2    | 将控件 actions()方法返回的QActions当作上下文菜单项,单击 鼠标右键后显示该菜单 |
  | Qt.CustomContextMenu      | 3    | 控件发送 customContextMenuRequested(Qpoint)信号,如果要 自定义菜单,用这个枚举值,并自定义一个处理函数 |
  | Qt.PreventContextMenu     | 4    | 控件不具有上下文菜单,所有的鼠标右键事件都传递到 mousePressEvent()和 mouseReleaseEvent()函数 |

#### 上下文菜单事件QContextMenuEvent应用实例

下面的程序建立一个空白窗口,在窗口单击鼠标右键,弹出上下文菜单,然后选择打开项,选择一幅图片后,在窗口上显示该图片。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 21:29
# File_name: 04-上下文菜单事件QContextMenuEvent 应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenu
from PySide6.QtGui import QPixmap, QPainter
import sys


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)  # 设置可接受拖放事件
        self.resize(600, 400)
        self.pixmap = QPixmap()  # 创建QPixmap图像

    def contextMenuEvent(self, event):
        contextMenu = QMenu(self)

        contextMenu.addAction("打开(&0)").triggered.connect(self.actionOpen_triggered)  # 槽连接

        contextMenu.addSeparator()
        contextMenu.addAction("退出(&E)").triggered.connect(self.close)  # 动作与槽连接

        contextMenu.exec(event.globalPos())

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect(), self.pixmap)

    def mouseDoubleClickEvent(self, event):  # 双击鼠标事件的处理函数
        self.actionOpen_triggered()

    def actionOpen_triggered(self):  # 打开文件的动作
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 剪贴板QClipboard

剪贴板 QClipboard类似于拖放,可以在不同的程序间用复制和粘贴操作来传递数据QClipboard 位于QtGui模块中,继承自 QObject类,用QClipboard(parent=None)方法可以创建剪贴板对象。

可以直接往剪贴板中复制文本数据、QPixmap 和 QImage,其他数据类型可以通过QMimeData来传递,剪贴板QClipboard 的常用方法如表所示。

| QClipboard的方法及参数类型 | 返回值的类型   | 说 明                                                 |
| -------------------------- | -------------- | ----------------------------------------------------- |
| setText(str)               | None           | 将文本复制到剪贴板                                    |
| text()                     | str            | 从剪贴板上获取文本                                    |
| text(str)                  | Tuple[str,str] | 从str指定的数据类型中获取文本,数据类型如 plain 或html |
| setPixmap(QPixmap)         | None           | 将QPixmap 图像复制到剪贴板上                          |
| pixmap()                   | QPixmap        | 从剪贴板上获取QPixmap 图像                            |
| setImage(QImage)           | None           | 将QImage图像复制到剪贴板上                            |
| image()                    | QImage         | 从剪贴板上获取QImage图像                              |
| setMimeData(QMimeData)     | None           | 将QMimeData数据赋值到剪贴板上                         |
| mimeData()                 | QMimeData      | 从剪贴板上获取QMimeData数据                           |
| elear()                    | None           | 清空剪贴板                                            |

**信号**

剪贴板的主要信号是 dataChanged(),当剪贴板上的数据发生变化时发送该信号



## 窗口和控件的常用事件

窗口和控件的常用事件包括窗口或控件的隐藏、显示、移动、缩放、重绘、关闭、获得和失去焦点等,通常需要重写这些事件的处理函数,以便达到特定的目的。

### 显示事件QShowEvent和隐藏事件QHideEvent

在用show()方法或 setVisible(True)方法显示一个顶层窗口之前会发生 QEvent.Show事件调用showEvent(QShowEvent)处理函数,显示事件类 QShowEvent 只有从QEvent 继承的属性没有自已特有的属性。

在用hide()方法或 setVisible(False)方法隐藏一个顶层窗口之前会发生 QEvent.Hide 事件调用hideEvent(QHideEvent)处理函数,隐藏事件类QHideEvent 只有从 QEvent 继承的属性,没有自已特有的属性。利用显示和隐藏事件的处理函数,可以在窗口显示之前或被隐藏之前做一些预处理工作。

### 缩放事件QResizeEvent和移动事件QMoveEvent

当一个窗口或控件的宽度和高度发生改变时会触发 QEvent.Resize 事件,调用resizeEvent(QResizeEvent)处理函数。

缩放事件类QResizeEvent 只有两个方法oldSize()和 size(),分别返回缩放前和缩放后的窗口尺寸QSize

当改变一个窗口或控件的位置时会触发 QEvent,Move 事件,调用moveEvent(QMoveEvent)处理函数。

移动事件类QMoveEvent 只有两个方法oldPos()和 pos(),分别返回窗口左上角移动前和移动后的位置 QPoint。

### 绘制事件QPaintEvent

绘制事件QPaintEvent是窗体系统产生的在一个窗口首次显示隐藏后又显示缩放窗口移动控件,以及调用窗口的 update() repaint()resize()方法时都会发 QEvent.Paint事件。

绘制事件发生时,会调用paintEvent(QPaintEvent)处理函数该函数是受保护的,不能直接用代码调用,通常在 paintEvent(QPaintEvent)处理函数中处理一些与绘图显示有关的事情。

绘制事件类QPaintEvent 只有两个方法 rect()和 region()方法分别返回被重绘的矩形区域 QRect 和裁剪区域 QRegion。

### 进人事件和离开事件 QEnterEvent

当光标进入窗口时,会触发 QEvent, Enter 进人事件,进人事件的处理函数是enterEvent(QEnterEvent),QEnterEvent 的方法如表所示;

| QEnterEvent的方法 | 返回值的类型 | QEnterEvent的方法 | 返回值的类型 |
| ----------------- | ------------ | ----------------- | ------------ |
| clone()           | QEnterEvent  | pos()             | QPoint       |
| globalPos()       | QPoint       | screenPos()       | QPointF      |
| globalX()         | int          | windowPos()       | QPointF      |
| globalY()         | int          | x()               | int          |
| localPos()        | QPointF      | y()               | int          |

当光标离开窗口时,会触发QEvent,Leave 离开事件离开事件的处理函数是 leaveEvent(QEvent)。可以重写这两个函数,以达到特定的目的。

### 焦点事件 QFocusEvent

一个控件获得键盘焦点时,可以接受键盘的输人。控件获得键盘焦点的方法很多,例如按 Tab 键、鼠标、快捷键等。

- 当一个控件获得和失去键盘输人焦点时,会触发 QEvent.FocusIn 和QEvent.FocusOut 事件,这两个事件的处理函数分别是 focusInEvent(QFocusEvent)和 focusOutEvent(QFocusEvent)
- 焦点事件类QFocusEvent 的方法有gotFocus() _lostFocus()和 reason()。
- 事件类型 type()
  - 当事件类型 type()的值是 QEvent.FocusIn 时gotFocus()方法的返回值是 True, 
  - 当事件类型type()的值是QEvent.FocusOut 时lostFocus()方法的返回值是 True; 
- reason()方法返回获得焦点的原因其返回值的类型是Qt.FocusReason,其值 有:
  - Qt.MouseFocusReason
  - Qt.TabFocusReason
  - Qt.BacktabFocusReason
  - Qt.ActiveWindowFocusReason
  - Qt.PopupFocusReason
  - Qt.ShortcutFocusReason
  - Qt.MenuBarFocusReason
  - Qt.OtherFocusReason

### 关闭事件0CloseEvent

当用户单击窗口右上角的X按钮或执行窗口的 close()方法时,会触发 QEvent,Close事件,调用closeEvent(QCloseEvent)处理该事件。

如果事件用ignore()方法忽略了,则什么也不会发生;

如果事件用accept()方法接收了,首先窗口被隐藏,在窗口设置了setAttribute(Qt.WA_DeleteOnClose,True)属性的情况下,窗口会被删除。

窗口事件类QCloseEvent 没有特殊的属性,只有从 QEvent 继承来的方法。



### 定时器事件QTimerEvent

从QObject 类继承的窗口和控件都会有startTimer(int,timerType =Qt.CoarseTimer)方法和 killTimer(int)方法。

startTimer()方法会启动一个定时器,并返回定时器的 ID 号。

- 如果不能启动定时器,则返回值是 0,参数 int 是定时器的事件间隔,单位是毫秒
- timerType 是定时器的类型,可以取
  - Qt.PreciseTimer
  - Qt.CoarseTimer
  - Qt.VeryCoarseTimer。
- 窗口或控件可以用startTimer()方法启动多个定时器,启动定时器后,会触发 timerEvent(QTimerEvent)事件,QTimerEvent是定时器事件类。
  - 用QTimerEvent的 timerId()方法可以获取触发定时器事件的定时器ID;
  - 用killTimer(int)方法可以停止定时器,参数是定时器的 ID。



下面的程序启动窗口上的两个定时器,这两个定时器的时间间隔不同,用定时器事件识别是哪个定时器触发了定时器事件,可用按钮停止定时器。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:29
# File_name: demo.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QHBoxLayout
from PySide6.QtCore import Qt
import sys


class MyWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.ID_1 = self.startTimer(500, Qt.TimerType.PreciseTimer)  # 创建第 1个定时器
        self.ID_2 = self.startTimer(1000, Qt.TimerType.CoarseTimer)  # 创建第2个定时器

        btn_1 = QPushButton("停止第1个定时器", self)
        btn_2 = QPushButton("停止第2个定时器", self)
        btn_1.clicked.connect(self.killTimer_1)
        btn_2.clicked.connect(self.killTimer_2)

        h = QHBoxLayout(self)
        h.addWidget(btn_1)
        h.addWidget(btn_2)

    def timerEvent(self, event):  # 定时器事件
        print("我是第" + str(event.timerId()) + "个定时器")

    def killTimer_1(self):
        if self.ID_1:
            self.killTimer(self.ID_1)  # 停止第1个定时器
            print(f"{'=' * 20}第1个定时器停止{'=' * 20}")

    def killTimer_2(self):
        if self.ID_2:
            self.killTimer(self.ID_2)  # 停止第2个定时器
            print(f"{'=' * 20}第2个定时器停止{'=' * 20}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWidget()

    win.show()
    sys.exit(app.exec())

```

## 事件过滤和自定义事件

前面已讲过,一个控件或窗口的event()函数是所有事件的集合点,可以在event()函数中设置某种类型的事件是接收还是忽略,另外还可以用事件过滤器把某种事件注册给其他控件或窗口进行监控、过滤和拦截。

### 事件的过滤

一个控件产生的事件可以交给其他控件进行处理,而不是由自身的处理函数处理,原控件称为被监测控件,进行处理事件的控件称为监测控件。要实现这个目的,需要将被监测控件注册给监测控件。

#### 事件过滤器的注册与删除

要把被监测对象的事件注册给监测控件,需要在被监测控件上安装监测器,被监测控件的监测器用installEventFilter(QObject)方法定义,其中QObject 是监测控件。

如果一个控件上安装了多个事件过滤器,则后安装的过滤器先被使用。用removeEventFilter(QObiect)方法可以解除监测。

#### 事件的过滤

要实现对被监测对象事件的过滤需要在监测对象上重写过滤函数 eventFilter(QObject,QEvent),其中参数 QObject 是传递过来的被监测对象,QEent 是被检测对象的事件类对象。

过滤函数如果返回 True,表示事件已经过滤掉了,如果返回 False,表示事件没有被过滤。

#### 事件过滤器的应用实例

下面的程序在两个QFrame控件上分别定义了两个QPushButton 按钮把这两个按钮的事件注册到窗口上,监控按钮的移动事件,如果移动其中的一个按钮,另一个按钮也同步移动。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:30
# File_name: 01-事件过滤器的应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag, QMouseEvent
import sys
from PySide6.QtCore import QMimeData, Qt.QEvent


class MyPushButton(QPushButton):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setText("MyPushButton")

    def mousePressEvent(self, event: QMouseEvent) -> None:  # 按键事件
        if event.button() == Qt.LeftButton:
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()
            self.drag.setMimeData(mime)
            self.drag.exec()


class MyFrame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)
        self.btn = MyPushButton(self)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())  # 获取指定位置的控件
        if self.child:
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setupi()
        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupi(self):
        self.frame_1 = MyFrame(self)
        self.frame_2 = MyFrame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)

        self.frame_1.btn.installEventFilter(self)  # 将 btn的事件注册到窗口 self上
        self.frame_1.btn.installEventFilter(self)  # 将btn的事件注册到窗口 self上

    def eventFilter(self, watched, event):  # 事件过滤函数
        if watched == self.frame_1.btn and event.type() == QEvent.Move:
            self.frame_2.btn.move(event.pos())
            return True

        if watched == self.frame_2.btn and event.type() == QEvent.Move:
            self.frame_1.btn.move(event.pos())
            return True

        return super().eventFilter(watched, event)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 自定义事件

除了可以直接使用PySide6 中标准的事件外,用户还可以自定义事件,指定事件产生的时机和事件的接受者。

#### 自定义事件类

用户定义自己的事件首先要创建一个继承自QEvent 的类,并给自定义事件一个ID号(值),该ID号的值只能在 QEvent,User(值为 1000)和 QEvent,MaxUser(值为 65535)之间,且不能和已有的ID号相同。

为保证ID 号的值不冲突,可以用QEvent 类的静态函数registerEventType(hint;int=-1)注册自定义事件的ID号,并检查给定的ID号是否合适如果ID 号合适,会返回指定的 ID 号值,如果不合适,则推荐一个ID 号值。

在自定义事件类中根据情况定义所需的属性和方法。

#### 自定义信号的发送

需要用QCoreApplication 的 sendEvent(receiver,event)函数或 postEvent(receiver;event)函数发送自定义事件,其中 receiver 是自定义事件的接收者,event 是自定义事件的实例化对象。

用sendEvent(receiver,event)函数发送的自定义事件被QCoreApplication的notify()函数直接发送给 receiver 对象,返回值是事件处理函数的返回值;

用postEvent(receiver,event)函数发送的自定义事件添加到事件队列中,它可以在多线程应用程序中用于在线程之间交换事件



#### 自定义事件的处理函数

控件或窗口上都有个 customEvent(event)丽数,用于处理自定义事件,自定义事件类的实例作为实参传递给形参event,也可以用event(event)函数处理在 customEvent(event)函数或 event(event)函数中根据事件类型进行相应的处理,也可用事件过滤器来处理。

#### 自定义事件的应用实例

下面的程序是建立自定义事件的例子,读者可以通过这个例子了解建立自定义事件的过程。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 23:07
# File_name: 02-自定义事件的应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag
import sys
from PySide6.QtCore import QMimeData, Qt.QEvent, QCoreApplication


# 自定义事件
class MyEvent(QEvent):
    # myID = QEvent,registerEventType(2000)
    def __init__(self, position, object_name=None):
        super().__init__(QEvent.User)
        # super().__init__(MyEvent.myID)

        self.__pos = position  # 位置属性,可对数据作其他处理
        self.__name = object_name  # 名称属性

    def get_pos(self):  # 自定义事件的方法
        return self.__pos

    def get_name(self):  # 自定义事件的方法
        return self.__name


class MyPushButton(QPushButton):
    def __init__(self, name=None, parent=None, window=None):
        super().__init__(parent)

        self.setText(name)
        self.windowl = window

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()  # 按健事件
            self.drag.setMimeData(mime)
            self.drag.exec()

    def moveEvent(self, event):
        self.__customEvent = MyEvent(event.pos(), self.objectName())  # 自定义事件
        QCoreApplication.sendEvent(self.window(), self.__customEvent)  # 发送事件


class MyFrame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())
        if self.child:  # 获取指定位置的控件
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setupUi()
        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupUi(self):
        self.frame_1 = MyFrame(self)
        self.frame_2 = MyFrame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)

        self.btn1 = MyPushButton("PushButton 1", self.frame_1, window=self)  # 按钮的名称
        self.btn1.setObjectName("button1")  # 按钮1

        self.btn2 = MyPushButton("PushButton 2", self.frame_1, window=self)  # 按钮的名称
        self.btn2.setObjectName("button2")  # 按钮2

        self.btn3 = MyPushButton("PushButton 3", self.frame_2, window=self)  # 按钮的名称
        self.btn3.setObjectName("button3")  # 按钮3

        self.btn4 = MyPushButton("PushButton 4", self.frame_2, window=self)  # 按钮的名称
        self.btn4.setObjectName("button4")  # 按钮4

    def customEvent(self, event):  # 自定义事件的处理函数
        if event.type() == MyEvent.User:  # if event.type() == MyEvent.myID:
            if event.get_name() == "button1":
                self.btn3.move(event.get_pos())

            if event.get_name() == "button2":
                self.btn4.move(event.get_pos())

            if event.get_name() == "button3":
                self.btn1.move(event.get_pos())

            if event.get_name() == "button4":
                self.btn2.move(event.get_pos())


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

