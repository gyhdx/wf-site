---
order: 13
---

# 13.事件与事件的处理函数2

## 鼠标事件和键盘事件

鼠标事件和键盘事件是用得最多的事件,通过鼠标和键盘事件可以拖拽控件、弹出快捷菜单等。

### 鼠标事件QMouseEvent和滚轮事件QWheelEvent 

鼠标事件类QMouseEvent涉及鼠标按键的单击释放和鼠标移动操作与QMouseEvent关联的事件类型有:

- QEvent.MouseButtonDblClick
- QEvent.MouseButtonPress
- QEvent.MouseButtonRelease
- QEvent.MouseMove

当在一个窗口或控件中按住鼠标按键或释放按键时会产生鼠标事件QMouseEvent

鼠标移动事件只会在按下鼠标按键的情况下才会发生,除非通过显式调用窗口的 setMouseTracking(True)函数来开启鼠标轨迹跟踪,这种情况下只要鼠标指针移动,就会产生一系列鼠标事件。

处理QMouseEvent类鼠标事件的函数有:

- mouseDoubleClickEvent(QMouseEvent)(双击鼠标按键)
- mouseMoveEvent(QMouseEvent)(移动鼠标)
- mousePressEvent(QMouseEvent)(按下鼠标按键)
- mouseReleaseEvent(QMouseEvent)(释放鼠标按键)。

鼠标滚轮的滚动事件类是QWheelEvent,处理QWheelEvent 滚轮事件的函数是 wheelEvent(QWheelEvent)。

#### 鼠标事件QMouseEvent 的常用方法

当产生鼠标事件时,会生成 QMouseEvent 类的实例对象,并将实例对象作为实参传递给相关的处理函数。

QMouseEvent 类包含了用于描述鼠标事件的参数。

QMouseEvent类在 QtGui模块中,它的常用方法如表 4-5所示,主要方法介绍如下。

- 用button()方法可以获取产生鼠标事件的按键,用buttons()方法获取产生鼠标事件时被按住的按键,返回值可以是: 
  - Qt.NoButton
  - Qt.AllButtons
  - Qt.LeftButton
  - Qt.RightButton
  - Qt.MidButton
  - Qt.MiddleButton
  - Qt.BackButton
  - Qt.ForwardButton
  - Qt.TaskButton
  - Qt.ExtraButtoni(i=1,2,...,24)
- 用source()方法可以获取鼠标事件的来源,返回值可以是:
  - Qt.MouseEventNotSynthesized(来自鼠标)
  - Qt.MouseEventSynthesizedBySystem(来自鼠标和触摸)
  - Qt.MouseEventSynthesizedByQt(来自触摸屏)
  - Qt.MouseEventSynthesizedByApplication(来自应用程序)
- 产生鼠标事件的同时,有可能按下了键盘上的 Ctrl Shift 或 Alt 等修饰键,用modifiers()方法可以获取这些键。modifiers()方法的返回值可以是:
  - Qt.NoModifier(没有修饰键)
  - Qt.ShiftModifier(Shift 键)
  - Qt.ControlModifier(Ctrl键)
  - Qt.AltModifier(Alt 键)
  - Qt.MetaModifier(Meta 键,Windows 系统为 window键)
  - Qt.KeypadModifier(小键盘上的键)
  - Qt.GroupSwitchModifier(Modeswitch 键)

- 用deviceType()方法可以获取产生鼠标事件的设备类型,返回值是 QInputDevice.DeviceType 的枚举值可取:
  - QInputDevice.Unknown
  - QInputDevice.Mouse
  - QInputDevice.TouchScreen 
  - QInputDevice.TouchPad 
  - QInputDevice.Stylus
  - QInputDevice.Airbrush
  - QInputDevice.Puck
  - QInputDevice.Keyboard
  - QInputDevice.AlDevices(以上设备中的任意一种)。
- 用flags()方法可以识别产生鼠标事件时的标识,返回值是 QtMouseEventFlags的枚举值,只可以取Qt.MouseEventCreatedDoubleClick,用于标识鼠标的双击事件



| QMouseEvent的方法 | 返回值的类型            | 说 明                                                        |
| ----------------- | ----------------------- | ------------------------------------------------------------ |
| button()          | Qt.MouseButton          | 获取产生鼠标事件的按键                                       |
| buttons()         | Qt.MouseButtons         | 获取产生鼠标事件时被按下的按键                               |
| flags()           | Qt.MouseEventFlags      | 获取鼠标事件的标识                                           |
| source()          | Qt.MouseEventSource     | 获取鼠标事件的来源                                           |
| modifiers()       | Qt.KeyboardModifiers    | 获取修饰键                                                   |
| device()          | QInputDevice            | 获取产生鼠标事件的设备                                       |
| deviceType()      | QInputDevice.DeviceType | 获取产生鼠标事件的设备类型                                   |
| globalPos()       | QPoint                  | 获取全局的鼠标位置                                           |
| globalX()         | int                     | 获取全局的X坐标                                              |
| globalY()         | int                     | 获取全局的Y坐标                                              |
| localPos()        | QPointF                 | 获取局部鼠标位置                                             |
| screenPos()       | QPointF                 | 获取屏幕的鼠标位置                                           |
| windowPos()       | QPointF                 | 获取相对于接受事件窗口的鼠标位置                             |
| pos()             | QPoint                  | 获取相对于控件的鼠标位置<br />此方法在新版本已经会发出弃用警告改用position() |
| position()        | QPoint                  | 获取相对于控件的鼠标位置                                     |
| x()               | int                     | 获取相对于控件的X坐标<br />此方法在新版本已经会发出弃用警告改用position().x() |
| y()               | int                     | 获取相对于控件的Y坐标<br />此方法在新版本已经会发出弃用警告改用position().y() |

#### 滚轮事件QWheelEvent的方法

滚轮事件 QWheelEvent类处理鼠标的滚轮事件,其常用方法如表所示大部分方法与QMouseEvent 的方法相同,主要不同的方法如下所述。

- 滚轮角度

  - angleDelta().y()返回两次事件之间鼠标竖直滚轮旋转的角度

  - angleDelta()x()返回两次事件之间鼠标水平滚轮旋转的角度。

  - 如果没有水平滚轮,则angleDetal().x()的值为 0,正数值表示滚轮相对于用户在向前滑动,负数值表示滚轮相对于用户在向后滑动

- pixelDelta()方法返回两次事件之间控件在屏幕上的移动距离(单位是像素)

- inverted()方法将 angleDelta()和 pixelDelta()的值与滚轮转之间的取值关系反向,即正数值表示滑轮相对于用户在向后滑动,负数值表示滑轮相对于用户在向前滑动。

- phase()方法返回设备的状态,返回值有:

  - Qt.NoScrollPhase(不支持滚动)
  - Qt.ScrollBegin(开始位置)
  - Qt.ScrollUpdate(处于滚动状态)
  - Qt.ScrollEnd(结束位置)
  - Qt.ScrollMomentum(不触碰设备,由于惯性仍处于滚动状态)

| QWheelEvent的方法 | 返回值的类型            |
| ----------------- | ----------------------- |
| angleDelta()      | QPoint                  |
| pixelDelta()      | QPoint                  |
| phase()           | Qt.ScrollPhase          |
| inverted()        | bool                    |
| source()          | Qt.MouseEventSource     |
| buttons()         | Qt.MouseButtons         |
| globalPos()       | QPoint                  |
| globalPosF()      | QPointF                 |
| deviceType()      | QInputDevice.DeviceType |
| modifiers()       | Qt.KeyboardModifiers\|  |
| globalPosition()  | QPointF                 |
| globalX()         | int                     |
| globalY()         | int                     |
| pos()             | QPoint                  |
| posF()            | QPointF                 |
| position()        | QPointF                 |
| x()               | int                     |
| y()               | int                     |

#### QMouseEvent 类和QWheelEvent 类的应用实例

下面的程序涉及鼠标单击、拖拽、双击和滚轮滚动的事件

双击窗口的空白处或者单击菜单,弹出打开图片的对话框,选择图片后,显示出图片

按住 Ctrl 键和鼠标左键并拖动鼠标可以移动图片,按住 Ctrl键并滚动滚轮可以缩放图片。

程序中通过控制绘图区域的中心位置来移动图像,通过控制图像区域的宽度和高度来缩放图像。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 23:00
# File_name: 01-鼠标事件QMouseEvent和滚轮事件QWheelEvent .py
from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenuBar
from PySide6.QtGui import QPixmap, QPainter, QMouseEvent, QWheelEvent
from PySide6.QtCore import QRect, QPoint, Qt.QPointF
import sys


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.resize(600, 600)
        self.pixmap = QPixmap()  # 创建QPixmap图像
        self.pix_width = 0  # 获取初始宽度
        self.pix_height = 0  # 获取初始高度
        self.translate_x = 0  # 用于控制x向平移
        self.translate_y = 0  # 并用于控制y向平移
        self.pixmap_scal_x = 0  # 用于记录图像的长度比例,用于图像缩放
        self.pixmap_scal_y = 0  # 用于记录图像的高度比例,用于图像缩放
        self.start = QPoint(0, 0)  # 鼠标单击时光标位置

        # 记录图像中心的变量,初始定义在窗口的中心
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))
        menuBar = QMenuBar(self)
        menuFile = menuBar.addMenu("文件(&F)")
        menuFile.addAction("打开(&0)").triggered.connect(self.actionOpen_triggered)
        menuFile.addSeparator()
        menuFile.addAction("退出(&E)").triggered.connect(self.close)  # 动作与槽连接

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        self.center = QPoint(self.center.x() + self.translate_x, self.center.y() + self.translate_y)

        # 图像绘制区域的左上角点,用于缩放图像
        point_1 = QPoint(self.center.x() - self.pix_width, self.center.y() - self.pix_height)

        # 图像绘制区域的右下角点,用于缩放图像
        point_2 = QPoint(self.center.x() + self.pix_width, self.center.y() + self.pix_height)

        self.rect = QRect(point_1, point_2)  # 图像绘制区域
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect, self.pixmap)

    def mousePressEvent(self, event: QMouseEvent):  # 鼠标按键按下事件的处理函数
        self.start: QPointF = event.position()  # 鼠标位置
        # 这里在Qt6使用pos()会发出弃用警告官方建议的是用position()代替pos()

    def mouseMoveEvent(self, event: QMouseEvent) -> None:  # 鼠标移动事件的处理函数
        if event.modifiers() == Qt.ControlModifier and event.buttons() == Qt.LeftButton:
            # 这里直接从event获取坐标会发出弃用警告,官方建议的是用position()间接获得坐标
            self.translate_x = event.position().x() - self.start.x()  # 鼠标的移动量
            self.translate_y = event.position().y() - self.start.y()

            self.start = event.position()
            self.update()  # 会调用paintEvent()

    def wheelEvent(self, event: QWheelEvent) -> None:  # 鼠标滚轮事件的处理函数
        if event.modifiers() == Qt.ControlModifier:
            if(self.pix_width > 10 and self.pix_height > 10) or event.angleDelta().y() > 0:
                self.pix_width = self.pix_width + int(event.angleDelta().y() / 10 * self.pixmap_scal_x)
                self.pix_height = self.pix_height + int(event.angleDelta().y() / 10 * self.pixmap_scal_y)

                self.update()

    def mouseDoubleClickEvent(self, event):  # 双击鼠标事件的处理函数
        self.actionOpen_triggered()

    def actionOpen_triggered(self):  # 打开文件动作
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *.jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)

        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽高
            self.pix_height = int(self.pixmap.height() / 2)

            self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
            self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
            self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

            self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```



### 键盘事件QKeyEvent

键盘事件QKeyEvent 涉及键盘键的按下和释放与QKeyEvent 关联的事件类型有:

> - QEvent.KeyPress
> - QEvent.KeyRelease 
> - QEvent.ShortcutOverride

处理键盘事件的函数是 keyPressEvent(QKeyEvent)和 keyReleaseEvent(QKeyEvent)。

- 当发生键盘事件时将创建QKeyEvent的实例对象,并将实例对象作为实参传递给处理函数键盘事件QKeyEvent的常用方法如所示主要方法介绍如下:
  - 如果同时按下多个键,可以用count()方法获取按键的数量。
  - 如果按下一个键不放,将连续触发键盘事件,用isAutoRepeat()方法可以获取某个事件是否是重复事件。
  - 用key()方法可以获取按键的Qtkey代码值不区分大小写;可以用text()方法获取按键的字符,区分大小写。
  - 用matches(QKeySequenceStandardKey)方法可以判断按下的键是否匹配标准的按键,QKeySequenceStandardKey中定义了常规的标准按键例如:
    - Ctrl+C表示复制、Ctrl+V表示粘贴、Ctrl+S表示保存Ctrl+0表示打开Ctrl+w或Ctrl+F4表示关闭。

| QKeyEvent的方法                   | 返回值的类型         | 说明                                |
| --------------------------------- | -------------------- | ----------------------------------- |
| count()                           | int                  | 获取按键的数量                      |
| isAutoRepeat()                    | bool                 | 获取是否是重复事件                  |
| key()                             | int                  | 获取按键的代码                      |
| matches(QKeySequence.StandardKey) | bool                 | 如果按键匹配标准的按键,则返 回 True |
| modifiers()                       | Qt.KeyboardModifiers | 获取修饰键                          |
| text()                            | Str                  | 返回按键上的字符                    |

### 鼠标拖放事件QDropEvent和QDragMoveEvent 

可视化开发中经常会用鼠标拖放动作来完成一些操作,例如把一个 docx 文档拖到Word 中直接打开,把图片拖放到一个图片浏览器中打开,拖放一段文字到其他位置等。

拖放事件包括鼠标进人、鼠标移动和鼠标释放事件,还可以有鼠标移出事件,对应的事件类型分别是:

- QEvent.DragEnter
- QEvent.DragMove 
- QEvent.Drop 
- QEvent.DragLeave。

拖放事件类分别为QDragEnterEvent,QDragMoveEvent,QDropEvent和QDragLeaveEvent,其实例对象中保存着拖放信息,例如被拖放文件路径、被拖放的文本等。拖放事件的处理函数分别是:

- dragEnterEvent(QDragEnterEvent)
- dragMoveEvent(QDragMoveEvent)
- dropEvent(QDropEvent)
- dragLeaveEvent(QDragLeaveEvent)

#### QDropEvent 和 QDragMoveEvent 的方法

QDragEnterEvent类是从QDropEvent类和QDragMoveEvent 类继承而来的,它没有自己特有的方法;

QDragMoveEvent 类是从QDropEvent 类继承而来的,它继承了QDropEvent类的方法,又添加了自已新的方法;

QDragLeaveEvent类是从QEvent类继承而来的,它也没有自己特有的方法。



QDropEvent类和QDragMoveEvent类的方法分别如表所示,主要方法介绍如下。

- 使一个控件或窗口接受拖放
  - 必须用setAcceptDrops(True)方法设置成接受拖放,
  - 在进入事件的处理函数 dragEnterEvent(QDragEnterEvent)中,需要把事件对象设置成 accept(),否则无法接受后续的移动和释放事件
- 在拖放事件中用mimeData()方法获取被拖放物体的QMimeData 数据MIME(multipurposeinternet mail extensions)是多用途互联网邮件扩展类型。关于QMimeData的介绍参见下面的内容。
- 在释放动作中,被拖拽的物体可以从原控件中被复制或移动到目标控件中
  - 复制或移动动作可以通过 setDropAction(QtDropAction)方法来设置其中Qt.DropAction可以取:
    - Qt.CopyAction(复制)
    - Qt.MoveAction(移动)
    - Qt.LinkAction(链接)
    - Qt.IgnoreAction(什么都不做)
    - Qt.TargetMoveAction(目标对象接管)
  - 另外系统也会推荐一个动作,可以用proposedAction()方法获取推荐的动作,用possibleActions()方法获取有可能实现的动作用dropAction()方法获取采取的动作。

**QDropEvent的常用方法**

| QDropEvent 的方法            | 返回值的类型         | 说明               |
| ---------------------------- | -------------------- | ------------------ |
| keyboardModifiers()          | Qt.KeyboardModifiers | 获取修饰键         |
| mimeData()                   | QMimeData            | 获取 mime 数据     |
| mouseButtons()               | Qt.MouseButtons      | 获取按下的鼠标按键 |
| pos()                        | QPoint               | 获取释放时的位置   |
| posF()                       | QPointF              | 获取释放时的位置   |
| dropAction()                 | Qt.DropAction        | 获取采取的动作     |
| possibleActions()            | Qt.DropActions       | 获取可能实现的动作 |
| proposedAction()             | Qt.DropAction        | 系统推荐的动作     |
| acceptProposedAction()       | None                 | 接受推荐的动作     |
| setDropAction(Qt.DropAction) | None                 | 设置释放动作       |
| source()                     | QObject              | 获取被拖对象       |

**QDragMoveEvenl的常用方法**

| QDragMoveEvent的方法 | 返回值的类型 | 说 ,明                               |
| -------------------- | ------------ | ------------------------------------ |
| accept()             | None         | 在控件或窗口的边界内都可接受移动事件 |
| accept(QRect)        | None         | 在指定的区域内接受移动事件           |
| ignore()             | None         | 在整个边界内部忽略移动事件           |
| ignore(QRect)        | None         | 在指定的区域内部忽略移动事件         |
| answerRect()         | QRect        | 返回可以释放的区域                   |

#### QMimeData类

QMimeData 类用于描述存放到粘贴板上的数据,并通过拖放事件传递粘贴板上的数据,从而在不同的程序间传递数据,也可以在同一个程序内传递数据。

创建 QMimeData 实例对象的方法是 QMimeData(),它在 QtCore模块中。QMimeData 可以存储的数据有文本、图像、颜色和地址等。

QMimeData类的方法如表所示,可以分项设置和获取数据,也可以用setData(str,QByteArray)方法设置数据

QMimeData的数据格式各种数据设置和获取的方法如表所示。

**QMimeData类的方法**

| QMimeData的方法及参数类型 | 返回值的类型 | 说明                |
| ------------------------- | ------------ | ------------------- |
| formats()                 | List[str]    | 获取格式列表        |
| hasFormat(str)            | bo0l         | 获取是否有某种格式  |
| removeFormat(str)         | None         | 移除格式            |
| setColorData(Any)         | None         | 设置颜色数据        |
| hasColor()                | bool         | 获取是否有颜色数据  |
| colorData()               | Any          | 获取颜色数据        |
| setHtml(str)              | None         | 设置Html数据        |
| hasHtml()                 | bool         | 判断是否有 Html数据 |
| html()                    | Str          | 获取 Html数据       |
| setImageData(Any)         | None         | 设置图像数据        |
| hasImage()                | bool         | 获取是否有图像数据  |
| imageData()               | Any          | 获取图像数据        |
| setText(str)              | None         | 设置文本数据        |
| hasText()                 | bool         | 判断是否有文本数据  |
| text()                    | str          | 获取文本数据        |
| setUrls(Sequence[QUrl])   | None         | 设置Url数据         |
| hasUrls()                 | bool         | 判断是否有Url数据   |
| urls()                    | List[QUrl]   | 获取 Url数据        |
| setData(str,QByteArray)   | None         | 设置某种格式的数据  |
| data(str)                 | QByteArray   | 获取某种格式的数据  |
| clear()                   | None         | 清空格式和数据      |

**QMimeData的数据格式和方法**

| 格式                | 是否存在   | 获取方法    | 设置方法       | 举例                            |
| ------------------- | ---------- | ----------- | -------------- | ------------------------------- |
| text/plain          | hasText()  | text()      | setText()      | setText("拖动文本")             |
| text/html           | hasHtml()  | html()      | setHtml()      | setHtml("拖动文本")         |
| text/uri-list       | hasUrls()  | urls()      | setUrls()      | setUrls([QUrl("www.qq.com/")])  |
| image/ *            | hasImage() | imageData() | setImageData() | setImageData(QImage("ix.png"))  |
| application/x-color | basColor() | colorData() | setColorData() | setColorData(QColor(23,56, 53)) |

#### 拖放事件的应用实例

下面的程序是在上一个实例的基础上增加了拖拽功能,除了可以双击窗口、用菜单打开二个图像文件外,也可以把一个图像文件拖拽到窗口上打开。

需要注意的是,要使窗口或控件接受拖放操作,应该用setAcceptDrops(bool)方法将其设置成 True。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:29
# File_name: demo.py

import sys
from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenuBar
from PySide6.QtGui import QPixmap, QPainter, QMouseEvent, QWheelEvent, QDragEnterEvent, QDropEvent
from PySide6.QtCore import QRect, QPoint, Qt.QPointF


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setAcceptDrops(True)  # 设置成接受拖放事件
        self.resize(600, 600)

        self.pixmap = QPixmap()  # 创建QPixmap图像
        self.pix_width = 0  # 获取初始宽度
        self.pix_height = 0  # 获取初始高度

        self.translate_x = 0  # 用于控制x向平移
        self.translate_y = 0  # 用于控制y向平移

        self.pixmap_scale_x = 0  # 用于记录图像的长度比例,用于图像缩放
        self.pixmap_scale_y = 0  # 用于记录图像的高度比例,用于图像缩放

        self.start = QPoint(0, 0)  # 鼠标单击时光标位置

        # 记录图像中心的变量,初始定义在窗口的中心
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))
        menuBar = QMenuBar(self)
        menuFile = menuBar.addMenu("文件(&F)")
        menuFile.addAction("打开(80)").triggered.connect(self.actionOpen_triggered)
        menuFile.addSeparator()
        menuFile.addAction("退出(8E)").triggered.connect(self.close)  # 动作与槽连接

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        self.center = QPoint(self.center.x() + self.translate_x, self.center.y() + self.translate_y)

        # 图像绘制区域的左上角点,用于缩放图像
        point_1 = QPoint(self.center.x() - self.pix_width, self.center.y() - self.pix_height)

        # 图像绘制区域的右下角点,用于缩放图像
        point_2 = QPoint(self.center.x() + self.pix_width, self.center.y() + self.pix_height)

        self.rect = QRect(point_1, point_2)  # 图像绘制区域
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect, self.pixmap)

    def actionOpen_triggered(self):
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *.jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)

        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽高
            self.pix_height = int(self.pixmap.height() / 2)

            self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
            self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
            self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

            self.update()

    def mousePressEvent(self, event: QMouseEvent) -> None:  # 鼠标按下事件处理
        self.start: QPointF = event.position()  # 鼠标位置
        # 这里在Qt6使用pos()会发出弃用警告官方建议的是用position()代替pos()

    def mouseMoveEvent(self, event: QMouseEvent) -> None:  # 鼠标移动事件处理
        if event.modifiers() == Qt.ControlModifier and event.buttons() == Qt.LeftButton:
            # 这里直接从event获取坐标会发出弃用警告,官方建议的是用position()间接获得坐标
            self.translate_x = event.position().x() - self.start.x()  # 鼠标的移动量
            self.translate_y = event.position().y() - self.start.y()

            self.start = event.position()
            self.update()  # 会调用paintEvent()

    def wheelEvent(self, event: QWheelEvent) -> None:  # 鼠标滚动事件
        if event.modifiers() == Qt.ControlModifier:
            if(self.pix_width > 10 and self.pix_height > 10) or event.angleDelta().y() > 0:
                self.pix_width = self.pix_width + int(event.angleDelta().y() / 3 * self.pixmap_scal_x)
                self.pix_height = self.pix_height + int(event.angleDelta().y() / 3 * self.pixmap_scal_y)

                self.update()

    def mouseDoubleClickEvent(self, event: QMouseEvent) -> None:
        self.actionOpen_triggered()

    def dragEnterEvent(self, event: QDragEnterEvent) -> None:  # 进入拖动事件
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent) -> None:  # 拖动释放事件
        urls = event.mimeData().urls()  # 获取被拖动文件的地址列表
        fileName = urls[0].toLocalFile()  # 将文件地址转成本地地址
        self.pixmap.load(fileName)
        self.pix_width = int(self.pixmap.width() / 2)  # 获取初始宽度
        self.pix_height = int(self.pixmap.height() / 2)  # 获取初始高度

        self.pixmap_scal_x = self.pix_width /(self.pix_width + self.pix_height)
        self.pixmap_scal_y = self.pix_height /(self.pix_width + self.pix_height)
        self.center = QPoint(int(self.width() / 2), int(self.height() / 2))

        self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 拖拽类QDrag

如果要在程序内部拖放控件,需要先把控件定义成可移动控件,可移动控件需要在其内部定义 QDrag 的实例对象。

QDrag 类用于拖放物体,它继承自 QObject 类,创建 QDrag实例对象的方法是 QDrag(QObject),参数 QObject 表示只要是从 QObject 类继承的控件都可以。

#### QDrag类的方法和信号

QDrag类的方法如表所示,主要方法介绍如下:



- 创建QDrag实例对象后,用exec(supportedActions;Qt.DropActions,delaultAction;QtDropAction)或 exec(supportedActions; Qt.DropActions一Qt.MoveAction)方法开启拖放,参数是拖放事件支持的动作和默认动作,QtDropAction可以取:
  - QtCopyAction(复制数据到目标对象)
  - Qt.MoveAction(移动数据到目标对象)
  - Qt.LinkAction(在目标和原对象之间建立链接关系)
  - Qt.IgnoreAction(忽略,对数据不做任何事情)
  - QtTargetMoveAction(目标对象接管数据)
- 用setMimeData(QMimeData)方法设置mime对象,传递数据;用mimeData()方法获取mime数据
- 用setPixmap(QPixmap)方法设置拖拽时鼠标显示的图像,用setDragCursor(QPixmap,QtDropAction)方法设置拖拽时光标的形状用setHotSpot(QPoint)方法设置热点位置。热点位置是拖拽过程中,光标相对于控件左上角的位置。
- 为了防止误操作,可以用QApplication的setStartDragDistance(int)方法和setStartDragTime(msec)方法设置拖动开始一定距离或一段时间后才开始进行拖放事件。

| QDrag的方法及参数类型                                        | 返回值的类型   | 说明                             |
| ------------------------------------------------------------ | -------------- | -------------------------------- |
| exec(supportedActions: Qt.DropActions = Qt.MoveAction)       | Qt.DropAction  | 开始拖动操作,并返回释放时的 动作 |
| exec(supportedActions: Qt.DropActions, defaultAction: Qt.DropAction) |                |                                  |
| defaultAction()                                              | Qt.DropAction  | 返回默认的释放动作               |
| setDragCursor(QPixmap, Qt.DropAction)                        | None           | 设置拖拽时的光标形状             |
| dragCursor(Qt.DropAction)                                    | QPixmap        | 获取拖拽时的光标形状             |
| setHotSpot(QPoint)                                           | None           | 设置热点位置                     |
| hotSpot()                                                    | QPoint         | 获取热点位置                     |
| setMimeData(QMimeData)                                       | None           | 设置拖放中传递的数据             |
| mimeData()                                                   | QMimeData      | 获取数据                         |
| setPixmap(QPixmap)                                           | None           | 设定拖拽时鼠标显示的图像         |
| pixmap()                                                     | QPixmap        | 获取图像                         |
| source()                                                     | QObject        | 返回被拖放物体的父控件           |
| target()                                                     | QObject        | 返回目标控件                     |
| supportedActions()                                           | Qt.DropActions | 获取支持的动作                   |
| cancel()                                                     | None           | 取消拖放                         |



#### 信号

| 信号                         | 说明 |
| ---------------------------- | ---- |
| actionChanged(Qt.DropAction) |      |
| targetChanged(QObject)       |      |

#### QDrag的应用实例

下面实例先重写了QPushButton 的 mousePressEvent()事件,在该事件中定义了QDrag的实例,这样QPushButton的实例对象就是可移动控件;

然后又重新定义了QFrame框架,在内部定义了两个QPushButton,重写了dragEnterEvent()函数dragMoveEvent()函数和dropEvent()函数。

程序运行后,可以随机用鼠标左键移动按钮的位置。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 20:51
# File_name: 03-QDrag的应用实例.py
from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag, QMouseEvent
import sys
from PySide6.QtCore import QMimeData, Qt


class MyPushButton(QPushButton):
    def __init__(self, parent=None):
        super().__init__(parent)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        if event.button() == Qt.LeftButton:  # 按键事件
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()
            self.drag.setMimeData(mime)
            self.drag.exec()


class MyFame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)
        self.btn_1 = MyPushButton(self)
        self.btn_1.setText("push button 1")
        self.btn_1.move(100, 100)
        self.btn_2 = MyPushButton(self)
        self.btn_2.setText("push button 2")
        self.btn_2.move(200, 200)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())  # 获取指定位置的控件
        event.accept()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())

    def dropEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi()

        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupUi(self):
        self.frame_1 = MyFame(self)
        self.frame_2 = MyFame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 上下文菜单事件QContextMenuEvent 

#### 上下文菜单事件QContextMenuEvent的方法

上下文菜单通常通过单击鼠标右键后弹出。

上下文菜单的事件类型是 QEvent.ContextMenu,处理函数是 contextMenuEvent(QContextMenuEvent),其中上下文菜单类QContextMenuEvent 的方法如表所示。主要方法介绍如下。

| QContextMenuEvent的方法 | 返回值的类型             | 说明                     |
| ----------------------- | ------------------------ | ------------------------ |
| globalPos()             | QPoint                   | 光标的全局坐标点         |
| globalX()               | int                      | 全局坐标的X值            |
| globalY()               | int                      | 全局坐标的Y值            |
| pos()                   | QPoint                   | 局部坐标点               |
| x()                     | int                      | 局部坐标的x值            |
| y()                     | int                      | 局部坐标的y值            |
| reason()                | QContextMenuEvent.Reason | 获得产生上下文菜单的原因 |
| modifiers()             | Qt.KeyboardModifiers     | 获取修饰键               |

- 用globalPos()方法、globalX()方法和 globalY()方法可以获得单击鼠标右键时的全局坐标位置

- 用pos()方法、X()方法和 y()方法可以获得窗口的局部坐标位置

- 用reason()方法可以获得产生上下文菜单的原因,返回值是 QContextMenuEvent.Reason 的枚举值,可能是:

  - QContextMenuEvent.Mouse 值为0,上下文菜单来源于鼠标
  - QContextMenuEvent.Keyboard 值为1,键盘(Windows 系统是菜单键)
  - QContextMenuEvent.Other 值为2,除鼠标及键盘之外的

- 在contextMenuEvent(QContextMenuEvent)处理函数中,用菜单的 exec(QPoint)方法在指定位置显示菜单,菜单可以是在其他位置已经定义好的,也可以是在处理函数中临时定义的。
  只有在窗口或控件的 contextMenuPlolicy 属性为Qt.DefaultContextMenu 时,单击鼠标右键才会执行处理函数,通常情况下 Qt.DefaultContextMenu是默认值。

- 如果不想弹出右键菜单,可以通过 setContextMenuPolicy(Qt.ContextMenuPolicy)方法将该属性设置为其他值,Qt.ContextMenuPolicy的取值如表所示:

  | Qt.ContextMenuPolicy 取值 | 值   | 说明                                                         |
  | ------------------------- | ---- | ------------------------------------------------------------ |
  | Qt.NoContextMenu          | 0    | 控件不具有上下文菜单,上下文菜单被推到控件的父窗口            |
  | Qt.DefaultContextMenu     | 1    | 控件或窗口的contextMenuEvent()被调用                         |
  | Qt.ActionsContextMenu     | 2    | 将控件 actions()方法返回的QActions当作上下文菜单项,单击 鼠标右键后显示该菜单 |
  | Qt.CustomContextMenu      | 3    | 控件发送 customContextMenuRequested(Qpoint)信号,如果要 自定义菜单,用这个枚举值,并自定义一个处理函数 |
  | Qt.PreventContextMenu     | 4    | 控件不具有上下文菜单,所有的鼠标右键事件都传递到 mousePressEvent()和 mouseReleaseEvent()函数 |

#### 上下文菜单事件QContextMenuEvent应用实例

下面的程序建立一个空白窗口,在窗口单击鼠标右键,弹出上下文菜单,然后选择打开项,选择一幅图片后,在窗口上显示该图片。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 21:29
# File_name: 04-上下文菜单事件QContextMenuEvent 应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QFileDialog, QMenu
from PySide6.QtGui import QPixmap, QPainter
import sys


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)  # 设置可接受拖放事件
        self.resize(600, 400)
        self.pixmap = QPixmap()  # 创建QPixmap图像

    def contextMenuEvent(self, event):
        contextMenu = QMenu(self)

        contextMenu.addAction("打开(&0)").triggered.connect(self.actionOpen_triggered)  # 槽连接

        contextMenu.addSeparator()
        contextMenu.addAction("退出(&E)").triggered.connect(self.close)  # 动作与槽连接

        contextMenu.exec(event.globalPos())

    def paintEvent(self, event):  # 窗口绘制处理函数,当窗口刷新时调用该函数
        painter = QPainter(self)  # 绘图
        painter.drawPixmap(self.rect(), self.pixmap)

    def mouseDoubleClickEvent(self, event):  # 双击鼠标事件的处理函数
        self.actionOpen_triggered()

    def actionOpen_triggered(self):  # 打开文件的动作
        fileDialog = QFileDialog(self)
        fileDialog.setNameFilter("图像文件(*.png *jpeg *.jpg)")
        fileDialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        if fileDialog.exec():
            self.pixmap.load(fileDialog.selectedFiles()[0])
            self.update()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 剪贴板QClipboard

剪贴板 QClipboard类似于拖放,可以在不同的程序间用复制和粘贴操作来传递数据QClipboard 位于QtGui模块中,继承自 QObject类,用QClipboard(parent=None)方法可以创建剪贴板对象。

可以直接往剪贴板中复制文本数据、QPixmap 和 QImage,其他数据类型可以通过QMimeData来传递,剪贴板QClipboard 的常用方法如表所示。

| QClipboard的方法及参数类型 | 返回值的类型   | 说 明                                                 |
| -------------------------- | -------------- | ----------------------------------------------------- |
| setText(str)               | None           | 将文本复制到剪贴板                                    |
| text()                     | str            | 从剪贴板上获取文本                                    |
| text(str)                  | Tuple[str,str] | 从str指定的数据类型中获取文本,数据类型如 plain 或html |
| setPixmap(QPixmap)         | None           | 将QPixmap 图像复制到剪贴板上                          |
| pixmap()                   | QPixmap        | 从剪贴板上获取QPixmap 图像                            |
| setImage(QImage)           | None           | 将QImage图像复制到剪贴板上                            |
| image()                    | QImage         | 从剪贴板上获取QImage图像                              |
| setMimeData(QMimeData)     | None           | 将QMimeData数据赋值到剪贴板上                         |
| mimeData()                 | QMimeData      | 从剪贴板上获取QMimeData数据                           |
| elear()                    | None           | 清空剪贴板                                            |

**信号**

剪贴板的主要信号是 dataChanged(),当剪贴板上的数据发生变化时发送该信号



## 窗口和控件的常用事件

窗口和控件的常用事件包括窗口或控件的隐藏、显示、移动、缩放、重绘、关闭、获得和失去焦点等,通常需要重写这些事件的处理函数,以便达到特定的目的。

### 显示事件QShowEvent和隐藏事件QHideEvent

在用show()方法或 setVisible(True)方法显示一个顶层窗口之前会发生 QEvent.Show事件调用showEvent(QShowEvent)处理函数,显示事件类 QShowEvent 只有从QEvent 继承的属性没有自已特有的属性。

在用hide()方法或 setVisible(False)方法隐藏一个顶层窗口之前会发生 QEvent.Hide 事件调用hideEvent(QHideEvent)处理函数,隐藏事件类QHideEvent 只有从 QEvent 继承的属性,没有自已特有的属性。利用显示和隐藏事件的处理函数,可以在窗口显示之前或被隐藏之前做一些预处理工作。

### 缩放事件QResizeEvent和移动事件QMoveEvent

当一个窗口或控件的宽度和高度发生改变时会触发 QEvent.Resize 事件,调用resizeEvent(QResizeEvent)处理函数。

缩放事件类QResizeEvent 只有两个方法oldSize()和 size(),分别返回缩放前和缩放后的窗口尺寸QSize

当改变一个窗口或控件的位置时会触发 QEvent,Move 事件,调用moveEvent(QMoveEvent)处理函数。

移动事件类QMoveEvent 只有两个方法oldPos()和 pos(),分别返回窗口左上角移动前和移动后的位置 QPoint。

### 绘制事件QPaintEvent

绘制事件QPaintEvent是窗体系统产生的在一个窗口首次显示隐藏后又显示缩放窗口移动控件,以及调用窗口的 update() repaint()resize()方法时都会发 QEvent.Paint事件。

绘制事件发生时,会调用paintEvent(QPaintEvent)处理函数该函数是受保护的,不能直接用代码调用,通常在 paintEvent(QPaintEvent)处理函数中处理一些与绘图显示有关的事情。

绘制事件类QPaintEvent 只有两个方法 rect()和 region()方法分别返回被重绘的矩形区域 QRect 和裁剪区域 QRegion。

### 进人事件和离开事件 QEnterEvent

当光标进入窗口时,会触发 QEvent, Enter 进人事件,进人事件的处理函数是enterEvent(QEnterEvent),QEnterEvent 的方法如表所示;

| QEnterEvent的方法 | 返回值的类型 | QEnterEvent的方法 | 返回值的类型 |
| ----------------- | ------------ | ----------------- | ------------ |
| clone()           | QEnterEvent  | pos()             | QPoint       |
| globalPos()       | QPoint       | screenPos()       | QPointF      |
| globalX()         | int          | windowPos()       | QPointF      |
| globalY()         | int          | x()               | int          |
| localPos()        | QPointF      | y()               | int          |

当光标离开窗口时,会触发QEvent,Leave 离开事件离开事件的处理函数是 leaveEvent(QEvent)。可以重写这两个函数,以达到特定的目的。

### 焦点事件 QFocusEvent

一个控件获得键盘焦点时,可以接受键盘的输人。控件获得键盘焦点的方法很多,例如按 Tab 键、鼠标、快捷键等。

- 当一个控件获得和失去键盘输人焦点时,会触发 QEvent.FocusIn 和QEvent.FocusOut 事件,这两个事件的处理函数分别是 focusInEvent(QFocusEvent)和 focusOutEvent(QFocusEvent)
- 焦点事件类QFocusEvent 的方法有gotFocus() _lostFocus()和 reason()。
- 事件类型 type()
  - 当事件类型 type()的值是 QEvent.FocusIn 时gotFocus()方法的返回值是 True, 
  - 当事件类型type()的值是QEvent.FocusOut 时lostFocus()方法的返回值是 True; 
- reason()方法返回获得焦点的原因其返回值的类型是Qt.FocusReason,其值 有:
  - Qt.MouseFocusReason
  - Qt.TabFocusReason
  - Qt.BacktabFocusReason
  - Qt.ActiveWindowFocusReason
  - Qt.PopupFocusReason
  - Qt.ShortcutFocusReason
  - Qt.MenuBarFocusReason
  - Qt.OtherFocusReason

### 关闭事件0CloseEvent

当用户单击窗口右上角的X按钮或执行窗口的 close()方法时,会触发 QEvent,Close事件,调用closeEvent(QCloseEvent)处理该事件。

如果事件用ignore()方法忽略了,则什么也不会发生;

如果事件用accept()方法接收了,首先窗口被隐藏,在窗口设置了setAttribute(Qt.WA_DeleteOnClose,True)属性的情况下,窗口会被删除。

窗口事件类QCloseEvent 没有特殊的属性,只有从 QEvent 继承来的方法。



### 定时器事件QTimerEvent

从QObject 类继承的窗口和控件都会有startTimer(int,timerType =Qt.CoarseTimer)方法和 killTimer(int)方法。

startTimer()方法会启动一个定时器,并返回定时器的 ID 号。

- 如果不能启动定时器,则返回值是 0,参数 int 是定时器的事件间隔,单位是毫秒
- timerType 是定时器的类型,可以取
  - Qt.PreciseTimer
  - Qt.CoarseTimer
  - Qt.VeryCoarseTimer。
- 窗口或控件可以用startTimer()方法启动多个定时器,启动定时器后,会触发 timerEvent(QTimerEvent)事件,QTimerEvent是定时器事件类。
  - 用QTimerEvent的 timerId()方法可以获取触发定时器事件的定时器ID;
  - 用killTimer(int)方法可以停止定时器,参数是定时器的 ID。



下面的程序启动窗口上的两个定时器,这两个定时器的时间间隔不同,用定时器事件识别是哪个定时器触发了定时器事件,可用按钮停止定时器。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:29
# File_name: demo.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QHBoxLayout
from PySide6.QtCore import Qt
import sys


class MyWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.ID_1 = self.startTimer(500, Qt.TimerType.PreciseTimer)  # 创建第 1个定时器
        self.ID_2 = self.startTimer(1000, Qt.TimerType.CoarseTimer)  # 创建第2个定时器

        btn_1 = QPushButton("停止第1个定时器", self)
        btn_2 = QPushButton("停止第2个定时器", self)
        btn_1.clicked.connect(self.killTimer_1)
        btn_2.clicked.connect(self.killTimer_2)

        h = QHBoxLayout(self)
        h.addWidget(btn_1)
        h.addWidget(btn_2)

    def timerEvent(self, event):  # 定时器事件
        print("我是第" + str(event.timerId()) + "个定时器")

    def killTimer_1(self):
        if self.ID_1:
            self.killTimer(self.ID_1)  # 停止第1个定时器
            print(f"{'=' * 20}第1个定时器停止{'=' * 20}")

    def killTimer_2(self):
        if self.ID_2:
            self.killTimer(self.ID_2)  # 停止第2个定时器
            print(f"{'=' * 20}第2个定时器停止{'=' * 20}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWidget()

    win.show()
    sys.exit(app.exec())

```

## 事件过滤和自定义事件

前面已讲过,一个控件或窗口的event()函数是所有事件的集合点,可以在event()函数中设置某种类型的事件是接收还是忽略,另外还可以用事件过滤器把某种事件注册给其他控件或窗口进行监控、过滤和拦截。

### 事件的过滤

一个控件产生的事件可以交给其他控件进行处理,而不是由自身的处理函数处理,原控件称为被监测控件,进行处理事件的控件称为监测控件。要实现这个目的,需要将被监测控件注册给监测控件。

#### 事件过滤器的注册与删除

要把被监测对象的事件注册给监测控件,需要在被监测控件上安装监测器,被监测控件的监测器用installEventFilter(QObject)方法定义,其中QObject 是监测控件。

如果一个控件上安装了多个事件过滤器,则后安装的过滤器先被使用。用removeEventFilter(QObiect)方法可以解除监测。

#### 事件的过滤

要实现对被监测对象事件的过滤需要在监测对象上重写过滤函数 eventFilter(QObject,QEvent),其中参数 QObject 是传递过来的被监测对象,QEent 是被检测对象的事件类对象。

过滤函数如果返回 True,表示事件已经过滤掉了,如果返回 False,表示事件没有被过滤。

#### 事件过滤器的应用实例

下面的程序在两个QFrame控件上分别定义了两个QPushButton 按钮把这两个按钮的事件注册到窗口上,监控按钮的移动事件,如果移动其中的一个按钮,另一个按钮也同步移动。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/1 20:30
# File_name: 01-事件过滤器的应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag, QMouseEvent
import sys
from PySide6.QtCore import QMimeData, Qt.QEvent


class MyPushButton(QPushButton):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setText("MyPushButton")

    def mousePressEvent(self, event: QMouseEvent) -> None:  # 按键事件
        if event.button() == Qt.LeftButton:
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()
            self.drag.setMimeData(mime)
            self.drag.exec()


class MyFrame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)
        self.btn = MyPushButton(self)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())  # 获取指定位置的控件
        if self.child:
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setupi()
        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupi(self):
        self.frame_1 = MyFrame(self)
        self.frame_2 = MyFrame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)

        self.frame_1.btn.installEventFilter(self)  # 将 btn的事件注册到窗口 self上
        self.frame_1.btn.installEventFilter(self)  # 将btn的事件注册到窗口 self上

    def eventFilter(self, watched, event):  # 事件过滤函数
        if watched == self.frame_1.btn and event.type() == QEvent.Move:
            self.frame_2.btn.move(event.pos())
            return True

        if watched == self.frame_2.btn and event.type() == QEvent.Move:
            self.frame_1.btn.move(event.pos())
            return True

        return super().eventFilter(watched, event)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

### 自定义事件

除了可以直接使用PySide6 中标准的事件外,用户还可以自定义事件,指定事件产生的时机和事件的接受者。

#### 自定义事件类

用户定义自己的事件首先要创建一个继承自QEvent 的类,并给自定义事件一个ID号(值),该ID号的值只能在 QEvent,User(值为 1000)和 QEvent,MaxUser(值为 65535)之间,且不能和已有的ID号相同。

为保证ID 号的值不冲突,可以用QEvent 类的静态函数registerEventType(hint;int=-1)注册自定义事件的ID号,并检查给定的ID号是否合适如果ID 号合适,会返回指定的 ID 号值,如果不合适,则推荐一个ID 号值。

在自定义事件类中根据情况定义所需的属性和方法。

#### 自定义信号的发送

需要用QCoreApplication 的 sendEvent(receiver,event)函数或 postEvent(receiver;event)函数发送自定义事件,其中 receiver 是自定义事件的接收者,event 是自定义事件的实例化对象。

用sendEvent(receiver,event)函数发送的自定义事件被QCoreApplication的notify()函数直接发送给 receiver 对象,返回值是事件处理函数的返回值;

用postEvent(receiver,event)函数发送的自定义事件添加到事件队列中,它可以在多线程应用程序中用于在线程之间交换事件



#### 自定义事件的处理函数

控件或窗口上都有个 customEvent(event)丽数,用于处理自定义事件,自定义事件类的实例作为实参传递给形参event,也可以用event(event)函数处理在 customEvent(event)函数或 event(event)函数中根据事件类型进行相应的处理,也可用事件过滤器来处理。

#### 自定义事件的应用实例

下面的程序是建立自定义事件的例子,读者可以通过这个例子了解建立自定义事件的过程。

```python
# -*- coding: UTF-8 -*-
# File date: Hi_2023/3/2 23:07
# File_name: 02-自定义事件的应用实例.py

from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QFrame, QHBoxLayout
from PySide6.QtGui import QDrag
import sys
from PySide6.QtCore import QMimeData, Qt.QEvent, QCoreApplication


# 自定义事件
class MyEvent(QEvent):
    # myID = QEvent,registerEventType(2000)
    def __init__(self, position, object_name=None):
        super().__init__(QEvent.User)
        # super().__init__(MyEvent.myID)

        self.__pos = position  # 位置属性,可对数据作其他处理
        self.__name = object_name  # 名称属性

    def get_pos(self):  # 自定义事件的方法
        return self.__pos

    def get_name(self):  # 自定义事件的方法
        return self.__name


class MyPushButton(QPushButton):
    def __init__(self, name=None, parent=None, window=None):
        super().__init__(parent)

        self.setText(name)
        self.windowl = window

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.drag = QDrag(self)
            self.drag.setHotSpot(event.position().toPoint())
            mime = QMimeData()  # 按健事件
            self.drag.setMimeData(mime)
            self.drag.exec()

    def moveEvent(self, event):
        self.__customEvent = MyEvent(event.pos(), self.objectName())  # 自定义事件
        QCoreApplication.sendEvent(self.window(), self.__customEvent)  # 发送事件


class MyFrame(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setFrameShape(QFrame.Shape.Box)

    def dragEnterEvent(self, event):
        self.child = self.childAt(event.position().toPoint())
        if self.child:  # 获取指定位置的控件
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        if self.child:
            self.child.move(event.position().toPoint() - self.child.drag.hotSpot())


class MyWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setupUi()
        self.resize(600, 400)
        self.setAcceptDrops(True)

    def setupUi(self):
        self.frame_1 = MyFrame(self)
        self.frame_2 = MyFrame(self)
        H = QHBoxLayout(self)
        H.addWidget(self.frame_1)
        H.addWidget(self.frame_2)

        self.btn1 = MyPushButton("PushButton 1", self.frame_1, window=self)  # 按钮的名称
        self.btn1.setObjectName("button1")  # 按钮1

        self.btn2 = MyPushButton("PushButton 2", self.frame_1, window=self)  # 按钮的名称
        self.btn2.setObjectName("button2")  # 按钮2

        self.btn3 = MyPushButton("PushButton 3", self.frame_2, window=self)  # 按钮的名称
        self.btn3.setObjectName("button3")  # 按钮3

        self.btn4 = MyPushButton("PushButton 4", self.frame_2, window=self)  # 按钮的名称
        self.btn4.setObjectName("button4")  # 按钮4

    def customEvent(self, event):  # 自定义事件的处理函数
        if event.type() == MyEvent.User:  # if event.type() == MyEvent.myID:
            if event.get_name() == "button1":
                self.btn3.move(event.get_pos())

            if event.get_name() == "button2":
                self.btn4.move(event.get_pos())

            if event.get_name() == "button3":
                self.btn1.move(event.get_pos())

            if event.get_name() == "button4":
                self.btn2.move(event.get_pos())


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MyWindow()

    win.show()
    sys.exit(app.exec())

```

